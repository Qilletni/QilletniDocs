{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Qilletni","text":"<p>Qilletni is a powerful Domain Specific Language for all things music. Seamlessly link streaming services and statistics platforms to curate playlists, find new music, automate playing, and integrate with external tools and APIs with its flexible syntax and library set.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Platform Integration: Import packages to gain access to different music platforms, such as spotify, tidal and lastfm</li> <li>Platform-Agnostic Types: Songs, artists, albums, etc. are automatically converted between music platforms for seamless use</li> <li>Weight-Based Music Selection: Use weighted collections for advanced playlist orchestration</li> <li>Native Java Bindings: Leverage Java libraries for enhanced functionality as if they were written in Qilletni</li> <li>Package Support: Create your own reusable package with our package manager, or leverage existing packages such as http, json, postgres, or metadata</li> </ul> <p>Get Started \u2192</p>"},{"location":"#get-started","title":"Get Started","text":"<p>Jump right into Qilletni with the Getting Started Guide, where you\u2019ll learn how to:</p> <ul> <li>Install Qilletni.</li> <li>Write your first program.</li> <li>Run <code>.ql</code> scripts to create and manage playlists.</li> </ul> <pre><code>// Weight the songs in your playlist\nweights myWeights =\n    | 20% \"Song A\" by \"Artist A\"  // 20% of the time, play \"Song A\"\n    | 10% \"Song B\" by \"Artist B\"\n    | 5x  \"Song C\" by \"Artist C\"  // Play \"Song C\" 5 times more often\n\n// Get your playlist &amp; assign weights to it\ncollection myCollection = \"My Playlist\" collection by \"username\" weights[myWeights]\n\n// Play 10 songs from your playlist\nplay myCollection limit[10]\n</code></pre> <p>Start Now \u2192</p>"},{"location":"#reference-documentation","title":"Reference Documentation","text":"<p>Dive deep into the Qilletni language and its libraries:</p> <ul> <li>Language Reference: Syntax, entities, functions, and control flow.</li> <li>Library Reference: Qilletni documentation for all official packages</li> <li>Java API Reference: Documentation for all API methods provided by Qilletni to make your own service providers packages with native bindings</li> </ul>"},{"location":"#why-qilletni","title":"Why Qilletni?","text":"<p>Working with any music service API is largely boilerplate, moving your focus away from what you're making to how to make it. Qilletni provides a familiar C-style syntax with its own music-specific features to speed up the process of creation.</p> <p>It's never been this easy to programmatically transfer songs or playlist from one music service to another, or manipulate how playlists are played.</p>"},{"location":"#example-program","title":"Example Program","text":"<p>Here\u2019s a sneak peek of what Qilletni can do:</p> <p>The following program takes a Spotify playlist, plays 2 songs from it, and then 3 recommended songs with high energy and low popularity. All songs are added to a new playlist on your account.</p> <pre><code>import \"spotify:recommendations.ql\"\nimport \"spotify:play_redirect.ql\"\nimport \"spotify:playlist_tools.ql\"\nimport \"std:util/stack.ql\"\n\n// Songs to play more frequently\nweights powerRotation =\n    | 85% [\"Wants I Need\" by \"156/Silence\",\n            \"Anti-Saviour\" by \"Voluntary Victim\",\n            \"Millstone\" by \"ROSARY\"]\n    | 15% [\"Heavy Rain\" by \"Konami Kode\",\n            \"Decay\" by \"Elwood Stray\",\n            \"All or Nothing\" by \"Foundations\"]\n\n// 30% of the time, choose from powerRotation\nweights myWeights =\n   |~ 30% powerRotation\n\n// A spotify playlist to play songs from, with weights\ncollection mySongs = \"My Playlist #59\" collection by \"rubbaboy\" weights[myWeights]\n\n// Redirect the \"play\" keyword to add played songs to a list, instead of playing them\nsong[] songList = []\nredirectPlayToList(songList)\n\n// Recommend Spotify songs\nRecommender recommender = new Recommender()\n        ..seedTracks = [\"Truth Serum\" by \"Gutter King\", \n                        \"Wayside\" by \"AEONS\"]\n        ..targetEnergy = 1.0     // High energy\n        ..targetPopularity = 10  // Low popularity\n\n// Recommend 30 songs, add them to a stack\nsong[] recs = recommender.recommend(30)\nStack recommendations = Stack.fromList(recs)\n\n// Play 2 shuffled songs from mySongs playlist, then 3 recommendations\nfor (recommendations.size() &gt;= 3) {\n    play mySongs limit[2]\n\n    for (i..3) {\n        play recommendations.pop()\n    }\n}\n\n// Create a new playlist in Spotify\nDate date = Date.now()\ncollection myNewPlaylist = createPlaylist(\"Qilletni generated on %d/%d\".format([date.getMonth(), date.getDay()]))\n\n// Add the songs to the new playlist\naddToPlaylist(myNewPlaylist, songList)\nprintf(\"Created a playlist with %s songs\", [songList.size()])\n</code></pre> <p>Explore more examples in our Examples Section \u2192</p>"},{"location":"examples/","title":"Code Examples","text":"<p>These are a couple quick examples of the Qilletni language. For package-specific examples, see the <code>examples/</code> directory in the relevant package, or see the Official Packages section for more detail and explanations.</p>"},{"location":"examples/#adding-metadata-tags","title":"Adding Metadata Tags","text":"<p>The following uses the metadata library. This attaches data to songs, albums and artists to help filter or organize music. This uses an internal database, so metadata persists.</p> <pre><code>import \"metadata:metadata.ql\"\n\nMetadata metadata = Metadata.createMetadata(Database.createDatabase(\"localhost\", 5444, \"metadata\", \"admin\", \"pass\"))\n\nsong mySong = \"God Knows\" by \"Knocked Loose\"\n\nmetadata.addTag(mySong, \"goated\")\nmetadata.addTag(mySong, \"cool\")\n\nprintf(\"Tags for song: %s\", [metadata.getTags(mySong).join(\", \")])  // Prints \"Tags for song: goated, cool\"\n</code></pre>"},{"location":"examples/#lastfm-to-spotify-conversion","title":"Last.fm to Spotify Conversion","text":"<p>As Qilletni supports automatic and efficient conversion between music providers, collections from one to another is seamless. The following takes a list of Last.fm songs and adds them to a newly created Spotify playlist.</p> <pre><code>import \"lastfm:lastfm.ql\"\nimport \"spotify:playlist_tools.ql\"\n\nprovider \"lastfm\" // (1)!\n\nPage page = new Page()\n                ..page = 1\n                ..count = 100\n\nLastFmResult result = getTopTracks(\"RubbaBoy\", \"3month\", page) // (2)!\n\nif (result.isError()) { // (3)!\n    printf(\"Error: %s\", [result.errorMessage])\n    exit(1)\n}\n\nfor (track : result.wrappedData.getValue()) {\n    printf(\"%s\\t plays  %s\", [track.playCount, track.track])\n}\n\nprovider \"spotify\" // (5)!\n\ncollection newPlaylist = createPlaylist(\"Top Song Playlist\") // (4)!\naddToPlaylist(newPlaylist, result.data)\n\nprint(\"Created a playlist with %s songs\".format([result.data.size()]))\n</code></pre> <ol> <li>Ensures the music provider is Last.fm</li> <li>Makes an API request to Last.fm to get the top 100 songs played in the last 3 months</li> <li>Methods that are API calls are handled a little more manually, so they should gracefully terminate if unsuccessful</li> <li>Create a new Spotify playlist and add the songs</li> <li>Switch the music provider to Spotify so conversion happens when needed</li> </ol>"},{"location":"examples/#spotify-recommendation-api","title":"Spotify Recommendation API","text":"<p>The Spotify library's Recommender entity, the full Spotify recommendation system can be utilized to fine tune music selections.</p> <pre><code>import \"spotify:recommendations.ql\"\nimport \"spotify:play_redirect.ql\"\nimport \"spotify:playlist_tools.ql\"\nimport \"std:util/stack.ql\"\n\nweights powerRotation =\n    | 85% [\"Wants I Need\" by \"156/Silence\", \"Monarch\" by \"Glasswaves\",\n            \"Anti-Saviour\" by \"Voluntary Victim\",\n            \"Millstone\" by \"ROSARY\",\n            \"Hell (I let the Devil In)\" by \"Breakwaters\",\n            \"Distance\" by \"Sleep Waker\",\n            \"Claustrophobic\" by \"Before I Turn\"]\n    | 15% [\"Heavy Rain\" by \"Konami Kode\",\n            \"Decay\" by \"Elwood Stray\",\n            \"All or Nothing\" by \"Foundations\"]\n\nweights metalWeights =\n   |~ 30% powerRotation\n\ncollection metalSongs = \"My Playlist #59\" collection by \"rubbaboy\" weights[metalWeights]\n\nsong[] songList = []\nredirectPlayToList(songList)\n\n// All recommended songs\nStack recommendations = new Stack()\n\nfun generateUniqueRecommendations() {\n    Recommender recommender = new Recommender()\n            ..seedTracks = [\"Truth Serum\" by \"Gutter King\", \n                            \"Paradise\" by \"Dark Island\",\n                            \"Anti-Saviour\" by \"Voluntary Victim\",\n                            \"Spiral\" by \"Feyn Entity\",\n                            \"Dark Tunnel\" by \"Beholder\"]\n            ..targetEnergy = 1.0\n            ..targetPopularity = 10\n\n    song[] recs = recommender.recommend(100)\n\n    for (rec : recs) {\n        if (!metalSongs.containsArtist(rec.getArtist())) {\n            recommendations.push(rec)\n        }\n    }\n\n    print(\"Generated %d unique recommendations\".format([recommendations.size()]))\n}\n\ngenerateUniqueRecommendations()\n\n// Play 2 shuffled songs from metal playlist, then 3 recommendations\nfor (recommendations.size() &gt;= 3) {\n    play metalSongs limit[2]\n\n    for (i..3) {\n        play recommendations.pop()\n    }\n}\n\n// Add all played songs to a new playlist\nDate date = Date.now()\ncollection myPlaylist = createPlaylist(\"Recs only %d/%d\".format([date.getMonth(), date.getDay()]))\n\naddToPlaylist(myPlaylist, songList)\nprint(\"Created a playlist with %s songs\".format([songList.size()]))\n</code></pre>"},{"location":"examples/#listening-for-song-playing","title":"Listening For Song Playing","text":"<p>Qilletni can also use hooks to monitor things like what song is currently being played. This ability also allows for server-side processing. The below example logs when the user changes what song they are playing on their account. For how this is implemented, see the Background Tasks page.</p> <pre><code>import \"spotify:hooks.ql\"\n\nfun songPlayCallback(sng) { // (1)!\n    printf(\"Playing:\\t%s - %s\", [sng.getTitle(), sng.getArtist().getName()])\n}\n\nonSongPlay(songPlayCallback)\n\n// Halt program forever, running background tasks\nprocessBackground()\n</code></pre> <ol> <li>This method is invoked every time a song is changed</li> </ol>"},{"location":"project_structure/","title":"Project Structure","text":"<p>Explore the types of projects, and how to organize files</p>"},{"location":"project_structure/#types-of-projects","title":"Types of Projects","text":"<p>With the Qilletni command, you can initialize two types of projects: an application and a library. An application is a standalone project that can be run, while a library is designed to be packaged and imported into other projects.</p> <p>A library may also be ran as an application is, but it is not the primary use case.</p> <p>To create the different types of projects, the following option in the qilletni command is used:</p> <pre><code>qilletni init -t &lt;type&gt;\n</code></pre> <p>Where <code>&lt;type&gt;</code> is either <code>application</code> or <code>library</code>. By default, it is set to <code>application</code>.</p> <p>Below are the structure and differences of each type of project. The first two sections will cover projects without native bindings, while the last section will cover projects with native bindings.</p>"},{"location":"project_structure/#applications","title":"Applications","text":"<p>To create an application, navigate to your desired directory and run the following command:</p> <pre><code>qilletni init &lt;project_name&gt;\n</code></pre> <p>The resulting project structure will be as follows:</p> <pre><code>project_name/\n\u2514\u2500\u2500 qilletni-src/\n    \u251c\u2500\u2500 project_name.ql\n    \u2514\u2500\u2500 qilletni_info.yml\n</code></pre> <p>Where <code>project_name.ql</code> is the initial source file for the project. All source files should be added to <code>qilletni-src/</code>.</p>"},{"location":"project_structure/#libraries","title":"Libraries","text":"<p>To create a library, navigate to your desired directory and run the following command:</p> <pre><code>qilletni init -t library &lt;project_name&gt;\n</code></pre> <p>The resulting project structure will be as follows:</p> <pre><code>project_name/\n\u251c\u2500\u2500 examples\n\u2502   \u2514\u2500\u2500 example1.ql\n\u2514\u2500\u2500 qilletni-src/\n    \u251c\u2500\u2500 project_name.ql\n    \u2514\u2500\u2500 qilletni_info.yml\n</code></pre> <p>In the example project, <code>example.ql</code> is an application file that uses the current library. Its contents will look something like:</p> <pre><code>import \"project_name:project_name.ql\"\n\n// Say hello from the sample function\nsayHello()\n</code></pre> <p>This file is not actually part of the project, so it is not included in the <code>qilletni-src/</code> directory. Examples of a library are conventionally stored in this directory, or its subdirectories. To run examples in this directory, see package development.</p> <p>The example source file for this will contain:</p> <pre><code>fun sayHello() {\n    print(\"Hello, World!\")\n}\n</code></pre> <p>Which defines a simple method an application importing it may use.</p>"},{"location":"project_structure/#project-with-native-bindings","title":"Project With Native Bindings","text":"<p>A project with native bindings is a project that has Java code bound to Qilletni native methods. To create a project with native bindings, use the <code>--native-class</code> option in the <code>qilletni init</code> command:</p> <pre><code>qilletni init --native-class com.example.qilletni.ProjectName &lt;project_name&gt;\n</code></pre> <p>The given class name is the class to initially create a project with. This may be changed or removed later. The resulting structure looks like:</p> <pre><code>project_name\n\u251c\u2500\u2500 build.gradle\n\u251c\u2500\u2500 gradle.bat\n\u251c\u2500\u2500 gradlew\n\u251c\u2500\u2500 settings.gradle\n\u251c\u2500\u2500 gradle\n\u2502   \u2514\u2500\u2500 wrapper\n\u2502       \u251c\u2500\u2500 gradle-wrapper.jar\n\u2502       \u2514\u2500\u2500 gradle-wrapper.properties\n\u251c\u2500\u2500 qilletni-src\n\u2502   \u251c\u2500\u2500 project_name.ql\n\u2502   \u2514\u2500\u2500 qilletni_info.yml\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 main\n        \u2514\u2500\u2500 java\n            \u2514\u2500\u2500 com\n                \u2514\u2500\u2500 example\n                    \u2514\u2500\u2500 ProjectName.java\n</code></pre> <p>A Qilletni project with native bindings uses the Gradle build system to compile the project. The <code>ProjectName.java</code> file is the initial native binding class, and more Java source files may be added in <code>src/main/java</code>.</p>"},{"location":"project_structure/#file-types","title":"File Types","text":"<p>Qilletni includes several different kind of files that can be used in a project. Below are the types of files and their purposes.</p>"},{"location":"project_structure/#source-files-ql","title":"Source Files <code>.ql</code>","text":"<p>A .ql` file is a Qilletni source file. It contains the code that will be interpreted by the Qilletni runtime. They may import other source files, or stay standalone.</p>"},{"location":"project_structure/#qilletni_infoyml","title":"<code>qilletni_info.yml</code>","text":"<p>The <code>qilletni_info.yml</code> file is a configuration file for the project. It contains metadata about the project, with available properties outlined below. It is used by the Qilletni runtime to display information about the project. When a library is packaged, it is parsed into a <code>qll.info</code> file.</p> <p>The available properties are:</p> Property Name Required Value Type Description name yes string The name of the project, typically snake_case version yes string The x.y.z version author yes string The author's name description no string A description of the library dependencies no package list A list of packages the library or application depends on provider no Java class string The Java class that implements the <code>ServiceProvider</code> interface, if the library includes a service provider native_bind_factory no Java class string The Java class that implements <code>NativeFunctionBindingFactory</code> to provide native methods' implementations with singleton instances of objects. See Native Binding Factories native_classes no Java class string list A list of Java classes that bind to Qilletni native methods. See Native Methods auto_import no source file list A list of Qilletni source file paths that are included in all files without an explicit <code>import</code>. Note: This should only be used in rare cases <p>The following is an example of all the properties being used:</p> qilletni_info.yml<pre><code>name: spotify\nversion: 1.0.0\nauthor: Adam Yarris\ndescription: A service provider that adds support for Spotify\ndependencies:\n  - 1.0.0:postgres\nprovider: dev.qilletni.music.spotify.provider.SpotifyServiceProvider\nnative_bind_factory: dev.qilletni.lib.spotify.SpotifyNativeFunctionBindingFactory\nnative_classes:\n  - dev.qilletni.lib.spotify.PlayRedirect\n  - dev.qilletni.lib.spotify.PlaylistToolsFunctions\nauto_import:\n  - core.ql\n</code></pre>"},{"location":"project_structure/#dependencies","title":"dependencies","text":"<p>The format for dependencies is</p> <p>// TODO</p>"},{"location":"language/documenting_code/","title":"Documenting Code","text":"<p>Qilletni supports its own style of documentation for functions, entities, and fields. This is markdown-based, with some additional structure. Unlike actual signatures, documentation can provide information regarding parameter or return types.</p> <p>The following is an example of documenation from the <code>Map</code> entity in the standard library. To see how it is rendered, see the Qilletni Docs for the entity.</p> <pre><code>/**\n * A [@java java.util.HashMap] wrapper that may store keys and values of any type.\n */\nentity Map {\n\n    /**\n     * The internal [@java java.util.HashMap] object, storing the map's state.\n     * @type @java java.util.HashMap\n     */\n    java _map = _emptyJavaMap()\n\n    /**\n     * Creates a new map from a list of key-value pairs.\n     *\n     * @param[@type list] list A list of key-value pairs\n     * @returns[@type core.Map] A new map with the given key-value pairs\n     */\n    static fun fromList(list) {\n        Map map = new Map()\n        int i = 0\n        for (i &lt; list.size()) {\n            map.put(list[i++], list[i++])\n        }\n\n        return map\n    }\n}\n</code></pre>"},{"location":"language/documenting_code/#documentation-structure","title":"Documentation Structure","text":""},{"location":"language/documenting_code/#type-referencing","title":"Type Referencing","text":"<p>In all text areas, Qilletni supports basic markdown support (no HTML). To reference a Qilletni type, the following syntax may be used:</p> <pre><code>[@type library.EntityName]\n[@type std.Map]\n</code></pre> <p>This is as simple as the library name and the entity name, which will turn into a link to the https://docs.qilletni.dev/ documentation page for the entity.</p> <p>As Qilletni may interface with Java closely, Java types may be referenced too, with the following format:</p> <pre><code>[@java java.util.HashMap]\n</code></pre> <p>This will produce a link to the official Javadocs of the class. These type references may be used in a text area, such as:</p> <pre><code>/**\n * You may reference a [@type std.Map] which is a wrapper around a [@java java.util.HashMap].\n */\n</code></pre>"},{"location":"language/documenting_code/#parameterreturn-type","title":"Parameter/Return Type","text":"<p>Parameters and return types may be referenced in a similar format. Neither are required, but recommended. This may be done by adding parameters at the end of the documentation block prefixed by <code>@param</code> and then a <code>@returns</code>. After that, a type may be provided (but is not required), the name of the parameter (if not a return), and then a description. </p> <p>The following formats are used to reference types after a <code>@param</code> or <code>@returns</code>:</p> Format Example When to use <code>[@type native-type]</code> <code>[@type string]</code> When referencing native types/placeholders: <code>int</code>, <code>double</code>, <code>string</code>, <code>boolean</code>, <code>collection</code>, <code>song</code>, <code>album</code>, <code>list</code>, <code>java</code>, <code>function</code> <code>[@type library.EntityName]</code> <code>[@type std.Artist]</code> When referencing any Entity <code>[@type @java class.path]</code> <code>[@type @java java.time.LocalDate]</code> When referencing an official Java type <p>If referencing a Java type, the format of <code>[@type @java ..]</code></p> <p>The following examples are valid documentation:</p> <pre><code>/**\n * @param[@type list] list                            A list of *key* and *value* pairs\n * @param[@type std.Artist] myArtist                  The artist to follow\n * @param[@type @java java.time.LocalDate] localDate  The [@java java.time.LocalDate] to manipulate\n * @param value                                       The value to process\n * @returns[@type lastfm.Page] The page to return\n */\n</code></pre>"},{"location":"language/documenting_code/#field-type-documenting","title":"Field Type Documenting","text":"<p>Fields can be documented as well, specifically in entities. A normal documentation block can be used, however with the <code>any</code> or <code>java</code> types, some ambiguity may want to be cleared up in docs. The following format, similar to parameter types, may be used to reference a Qilletni or Java field type:</p> <pre><code>/**\n * The internal [@java java.time.LocalDate] object to store the date info.\n * @type @java java.time.LocalDate\n */\njava _date\n\n/**\n * The [@type string] to set.\n * @type string\n */\nany value\n</code></pre> <p>This type must appear at the end of the documentation string.</p>"},{"location":"language/introduction/","title":"Introduction to Qilletni","text":"<p>This page is a brief introduction to Qilletni, with some samples of its main features. To get begin programming in Qilletni, check out the Getting Started guide.</p>"},{"location":"language/introduction/#hello-world","title":"Hello World","text":"<p>When a file is ran or imported, all top-level code is executed in order. This makes simple programs like a Hello World application very easy:</p> <pre><code>print(\"Hello, World!\")\n</code></pre>"},{"location":"language/introduction/#variables","title":"Variables","text":"<p>All variables are assigned a type upon initialization. The concept of a null or empty variable does not exist, so a variable must have a value assigned to it initially, except when declaring an entity (this is more of a late-assignment, and still does not provide value-less variables). Variables are relatively weakly typed, and if initialized with a non-<code>any</code> type, it must adhere to that type.</p> <pre><code>int i = 10\ndouble d = 1.23\nstring s = \"foo bar\"\nsong mySong = \"Spiral\" by \"Feyn Entity\"\nalbum myAlbum = \"Requiem\" album by \"Last Falling Rose\"\nstring[] names = [\"Bob\", \"Tim\"]\nany[] stuff = [\"a string\", 42]\n</code></pre> <p>Some types have unfamiliar syntax than other languages. See the built-in types page to see how to define them and how they work.</p>"},{"location":"language/introduction/#control-flow-statements","title":"Control flow statements","text":"<p>Qilletni supports basic control flow statements, such as:</p> <pre><code>if (age &gt;= 18) {\n    print(\"Is an adult\")\n} else {\n    print(\"Is a minor\")\n}\n\nfor (name : names) {\n    print(name)\n}\n\nfor (i..10) { // Prints 0-9\n    print(i)\n}\n\nfor (i..infinity) { // Prints from 0 to infinity until exited\n    print(i)\n}\n\nfor (i != 0) {\n    i = getNumber()\n}\n</code></pre>"},{"location":"language/introduction/#functions","title":"Functions","text":"<p>Functions are defined without input/return types, typically specified in docs (see Documenting Code).</p> <pre><code>fun fibonacci(n) {\n    if (n == 0 || n == 1) {\n        return n\n    }\n    return fibonacci(n - 1) + fibonacci(n - 2)\n}\n\nint result = fibonacci(10)\n</code></pre> <p>If a method doesn't return anything but is expected to, an error occurs during runtime. If you may not want to return a value, see the Optional type. Functions may also be overridden with a different number of arguments.</p>"},{"location":"language/introduction/#comments","title":"Comments","text":"<p>Comments usually start with <code>//</code></p> <pre><code>// This is a comment\n\n/**\n * This is a documentation comment\n */\n</code></pre> <p>For more information on documentation comments and their standard format, see Documenting Code.</p>"},{"location":"language/introduction/#imports","title":"Imports","text":"<p>Importing libraries or files may be done through a normal <code>import</code> or an aliased import.</p> <pre><code>import \"spotify:play_redirect.ql\"\n\nimport \"spotify:recommendations.ql\" as recommendation\n</code></pre> <p>Unaliased imports put the contents of the imported file in the same scope as the file importing it. Aliased imports make the scope of the imported file accessible through the alias given. In the above example, everything in <code>recommendations.ql</code> is accessible via <code>recommendation.recommendationMethod()</code>.</p>"},{"location":"language/introduction/#entities","title":"Entities","text":"<p>Entities are equivalent to objects/classes in many other programming languages. They have defined properties holding data with functions in it.</p> <pre><code>entity Person {\n    string name\n    int age\n    int armCount = 2\n\n    Person(name, age)\n\n    static fun createChild(name) {\n        return new Person(name, 0)\n    }\n\n    // Instance function: uses the entity's own properties\n    fun introduce() {\n        printf(\"Hi, I'm %s and I'm %d years old! I have %d arms.\", [name, age, armCount]))\n    }\n}\n</code></pre> <p>Static functions are not reliant on an instance of an entity, so the above may be invoked like <code>Person.createChild(\"name\")</code>.</p> <p>Constructors of entities do not contain a body, so initialization logic should rely on a static factory method. Parameters of a constructor should include all uninitialized parameters, as Qilletni requires all values to have a value.</p>"},{"location":"language/service_providers/","title":"Service Providers","text":"<p>Music is handled through a service provider, which is a Qilletni package with additional features. This is often an implementation of an API, such as Spotify, that handles necessary caching and lookups, abstracted by Qilletni's API. This allows for drop-in replacements of what music service is being used.</p> <p>When using a service provider, API tokens must be provided. This is because just as with a language using an API's wrapper, Qilletni is using an API directly, unlike a client-facing application. When using a service provider, ensure to adhere to the terms of the service provider's API.</p> <p>The following is an example of getting a song from the Last.fm provider. The Last.fm provider also provides access to API methods to get specific data on the user.</p> <pre><code>import \"lastfm:lastfm.ql\"\n\nprovider \"lastfm\" // (1)!\n\nprint(\"\\tProvider is Last.fm\")\n\nPage page = new Page()\n                ..page = 1\n                ..count = 1\n\nsong topSong = getTopTracks(\"RubbaBoy\", \"7day\", page).data[0] // (2)!\n\nprint(topSong)\n\nprovider \"spotify\" { // (3)!\n    print(\"\\tProvider is Spotify\")\n\n    print(topSong.getId()) // (4)!\n}\n</code></pre> <ol> <li>A <code>provider</code> statement without brackets switches the whole program to use the provider, in this case, Last.fm</li> <li>Gets a Last.fm song</li> <li>Everything in this block is now in the Spotify provider, so anything accessed will automatically convert to this service provider</li> <li>Prints the Spotify ID of the song</li> </ol> <p>This results in the following output, which prints out the user's top song from Last.fm, and then its Spotify ID:</p> <pre><code>        Provider is Last.fm\nsong(\"Late Night Drinking\" by \"nowifi\")\n        Provider is Spotify\n4Xl2xUFmj2xbszjYjEXxkx\n</code></pre> <p>Conversions between service providers are only done if needed, and data is cached for quick switching.</p>"},{"location":"language/service_providers/#syntax","title":"Syntax","text":"<p>Service provider switching may be done two ways, full-program switching or through a block. Full-program switching is done via:</p> <pre><code>provider \"library name\"\n</code></pre> <p>If you are developing a library, be careful with this syntax because the running application may be left off with a different provider than originally intended. The other syntax is safer, and only sets the provider for the given code block:</p> <pre><code>provider \"library name\" {\n    // Code here\n}\n</code></pre> <p>The name of the provider is the library's name.</p>"},{"location":"language/service_providers/#the-native-feature-set","title":"The Native Feature Set","text":"<p>Service providers have varying levels of implementation, depending on both maturity and APIs available from the service.</p> <p>Qilletni specifies a specific \"native\" feature set that is expected for service providers to support. This feature set is generic enough where most service providers should be able to support them, including:</p> <ul> <li>Song lookup</li> <li>Artist lookup</li> <li>User lookup</li> <li>Collection lookup</li> <li><code>play</code> functionality</li> <li>Music type conversion between service providers</li> </ul> <p>On top of these, service providers may have additional features through the normal package interface. This may include things like playlist modification, recommendations, etc.</p>"},{"location":"language/syntax/extension_functions/","title":"Extension Functions","text":""},{"location":"language/syntax/extension_functions/#extension-functions","title":"Extension Functions","text":"<p>Extension functions are functions that may be invoked on an object, like it was an entity that has the function defined in it. They may be applied to any type, using the <code>on</code> keyword in the following format:</p> <pre><code>fun printThis(str) on string {\n    printf(\"Printing this string: ''%s;\", [str])\n}\n\n\"My String\".printThis()  // Prints \"Printing this string: 'My String'\"\n</code></pre> <p>The first parameter of the function definition is the object that the function is bring invoked on. Notice that it is implicitly set, and is not included in the call to the function. Other parameters may be added after that, such as the following:</p> <pre><code>fun printThis(str, n) on string {\n    for (i..n) {\n        printf(\"Printing this string: ''%s;\", [str])\n    }\n}\n\n\"My String\".printThis(2)  // Prints \"Printing this string: 'My String'\" twice\n</code></pre> <p>Extension functions also work for entities.</p> <pre><code>entity Cat {\n    string name\n\n    Cat(name)\n}\n\nfun sayHi(cat) on Cat {\n    printf(\"Hello, %s\", [cat.name])\n}\n\nCat cat = new Dat(\"Olive\")\ncat.sayHi()  // Prints \"Hello, Olive\"\n</code></pre>"},{"location":"language/syntax/extension_functions/#native-method-extensions","title":"Native Method Extensions","text":"<p>Extension methods may be native methods too. The only difference in definition is they don't include the invoked on parameter, and as normal for native functions, don't include a body.</p> <pre><code>native fun sayHi() on Cat\n</code></pre> <p>For implementing these, see Native Methods.</p>"},{"location":"language/syntax/operators/","title":"Operators","text":"<p>The following is an estimation of Qilletni's operator associativity and precedence, from highest to lowest.</p> Description Operator Associativity Notes member access <code>.</code> Left-to-right Accesses properties/functions unary postfix <code>x++</code> <code>x--</code> Left-to-right <code>x++</code> <code>x--</code> increments/decrements after returning the old value unary prefix <code>!</code> <code>++x</code> <code>--x</code> Right-to-left <code>!</code> inverts a boolean, and <code>++x</code> and <code>--x</code> increments/decrements before returning the new value multiplicative <code>*</code> <code>/~</code> <code>/</code> <code>%</code> Right-to-left <code>/~</code> is floor (integer) division, <code>/</code> is floating division, <code>%</code> is modulo additive <code>+</code> <code>-</code> Left-to-right Handles addition/subtraction, <code>+</code> also handles string concatenation between numbers, strings, direct function calls and parentheses-wrapped expressions <code>( expression )</code> range/cascade <code>..</code> Left-to-right Used both in <code>for (i..10)</code> or through cascade assignment <code>foo..bar = 0 ..baz = 1</code> relational <code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code> <code>==</code> <code>!=</code> Left-to-right Compares two expressions, returning a boolean logical AND <code>&amp;&amp;</code> Left-to-right Checks if both sides of the keyword are true logical OR <code>||</code> Left-to-right Checks if at least one side of the keyword is true type check <code>is</code> Left-to-right Checks the type of a variable assignment <code>=</code> <code>+=</code> <code>-=</code> Right-to-left <code>=</code> is not an expression, and does not return a value <p>Most operators create an expression. The only exceptions are assignment and range/cascade. Operators that may require some additional information are outlined below. Most are used how you would expect.</p>"},{"location":"language/syntax/operators/#type-checking","title":"Type checking","text":"<p>Qilletni has relatively loose type checking, mainly in function parameters. The <code>as</code> operator is used to check what a variable is set to.</p> <pre><code>any a = \"Hello\"\n\nprintf(\"a = %s\", [a is string]) // prints \"a = true\"\n\na = 123\n\nprintf(\"a = %s\", [a is string]) // prints \"a = false\"\nprintf(\"a = %s\", [a is int])    // prints \"a = true\"\n</code></pre> <p>The <code>as</code> operator may check if something is any native type or entity name. It may not be used to check if something is <code>any</code>, as everything is <code>any</code>.</p>"},{"location":"language/syntax/operators/#cascade-notation","title":"Cascade notation","text":"<p>Cascade notation is a special form of assignment used with entities. Instead of returning nothing, the operator returns the result of the expression on the left, allowing for combined assignments. Take this code, which uses traditional assignment:</p> <pre><code>Coord coordinate = new Coord()\ncoordinate.x = 1\ncoordinate.y = 2\ncoordinate.z = 3\n</code></pre> <p>The cascade operator would allow you to do:</p> <pre><code>Coord coordinate = new Coord()\n    ..x = 1\n    ..y = 2\n    ..z = 3\n</code></pre> <p>In one single expression.</p>"},{"location":"language/syntax/operators/#range-notation","title":"Range notation","text":"<p>The range operator is unique to the <code>for</code> loop. It allows the specification of when the loop should end. Loops are relatively primitive, in that with built-in syntax, they always start with 0 and go to an exclusive number. Examples of this notation are:</p> <pre><code>for (i..10) { // // Prints 0-9\n    print(i)\n}\n\nfor (i..infinity) { // Prints from 0 to infinity until exited\n    print(i)\n}\n</code></pre> <p>Note that <code>infinity</code> may also follow the range operator, making the loop repeat forever until it is exited out of.</p>"},{"location":"language/types/built_in_types/","title":"Built-in types","text":"<p>Qilletni comes with following primary types to get started with in its standard library:</p> <ul> <li>Numbers (<code>int</code>, <code>double</code>)</li> <li>Strings (<code>string</code>)</li> <li>Booleans (<code>boolean</code>)</li> <li>Lists (<code>type[]</code>)</li> <li>Maps (<code>Map</code>)</li> <li>Optional (<code>Optional</code>)</li> <li>Any (<code>any</code>)</li> <li>Songs (<code>song</code>)</li> <li>Albums (<code>album</code>)</li> <li>Playlists (<code>collection</code>)</li> <li>Artists (<code>Artist</code>)</li> <li>Weights (<code>weights</code>)</li> <li>Java Reference (<code>java</code>)</li> </ul>"},{"location":"language/types/built_in_types/#numbers","title":"Numbers","text":"<p>Numbers in Qilletni are relatively rudimentary. There are two types, <code>int</code> and <code>double</code>. <code>int</code>s can go from <code>`-2^31</code> to <code>2^31 - 1</code>, whereas <code>double</code>s are floating points, and follow the IEEE 754 standard for 64-bit floating point numbers.</p> <p><code>int</code>s and <code>double</code>s may be converted to one another, via the syntax below.</p> <pre><code>double d = 3.14\n\nint i = int(d)\nprint(i)  // Prints \"3\"\n\ndouble d2 = double(i)\nprint(d2)  // Prints \"3.0\"\n</code></pre> <p>If math operations go between both <code>int</code>s and <code>double</code>s, generally they will return as a <code>double</code>. Exclusions for this are addition, subtraction, and integer division.</p>"},{"location":"language/types/built_in_types/#strings","title":"Strings","text":"<p>Strings are immutable sequences of characters. They may be formatted via</p> <pre><code>\"Number: %d  Float (3 decimal places): %.3f  String: %s\".format([123, 3.14159, \"hello\"])\n// Outputs:\n//   Number: 123  Float (3 decimal places): 3.142  String: hello\n</code></pre> <p>The <code>format</code> method takes in an array of expressions to format with the string. For simplicity, formatting follows Java's implementation, outlined here.</p> <p>The same can be done with <code>printf</code>:</p> <pre><code>printf(\"Hello %s!\", [\"World\"])  // Prints \"Hello World!\"\n</code></pre> <p>Which is a formatting variation of the <code>print</code> command. Strings may also be escaped with a backslash: <pre><code>print(\"Hello \\\"World!\\\"\")  // Prints 'Hello \"World!\"'\n</code></pre></p>"},{"location":"language/types/built_in_types/#lists","title":"Lists","text":"<p>Lists are ordered collections of either built-in types or entity instances, that may be manipulated. They may ether be created explicitly with a type or have its type assumed implicitly.</p> <pre><code>string[] strs1 = [\"a\", \"b\", \"c\"]  // Implicit type\nstring[] strs2 = string[\"d\", \"e\", \"f\"]  // Explicit type\n\nany[] strs3 = [\"g\", \"h\", \"i\"]  // Implicitly a string[]\nany[] strs4 = string[\"j\", \"k\", \"l\"]  // Explicitly a string[]\n\nprint(strs1 is string[])\nprint(strs2 is string[])\nprint(strs3 is string[])\nprint(strs4 is string[])\n\nstrs1 = [1, 2, 3]  // Errors!\n//      ^ Even through the original list was defined with an implcit type, the variable retains its set type forever\n\nany[] ints = [1, 2, 3]  // Implicit type\nstrs3 = [1, 2, 3]\n\nprint(ints is int[])  // true\nprint(strs3 is int[])  // true\nprint(strs3 is string[])  // false  strs3 was any any[] but is not an int[]\n\nstring[] uhOh = string[1, \"b\", 3.0]  // Errors!\n//              ^ Cannot force all of these types to be strings\n</code></pre>"},{"location":"language/types/built_in_types/#implicit-subtypes","title":"Implicit subtypes","text":"<p>Every list has a subtype. A list's subtype may either be defined explicitly in the list expression, or implicitly in the expression. As per normal variables, once a variable is defined with a type, it may not change. The below example shows a list variable being created with a defined type <code>string[]</code> but then assigned to a  list with an implicitly defined type. This list variable is forever a <code>string[]</code>.</p> <pre><code>string[] strs1 = [\"a\", \"b\", \"c\"]  // Implicit type\n\nstrs1 = [1, 2, 3]  // Errors!\n//      ^ Even through the original list was defined with an implcit type, the variable retains its set type forever\n</code></pre> <p>If a list is created with an implicit type and not all types are the same in the list, it is assumed an <code>any[]</code>, as shown below.</p> <pre><code>any[] mixed = [1, \"b\", 3.0]\n</code></pre> <p>An <code>any</code> list may also be created with a consistent type. This means the actual containing list has a type, but the variable could be reassigned to a list with another type. This is done through a type assumption of its contents upon creation.</p> <pre><code>any[] consistent = [1, 2, 3]\nprint(consistent is int[])  // true\n\nconsistent = [\"a\", \"b\", \"c\"]\nprint(consistent is string[])  // true\n\nconsistent = any[1, 2, 3]\nprint(consistent is int[])     // false\nprint(consistent is string[])  // false\n</code></pre> <p>The end of the above example demonstrates that <code>any</code> is also a type, and a list can be created with that as its subtype. This means any value could be added to the list in the future, despite it currently containing only one type. No type assumptions are made in an <code>any[]</code> definition.</p>"},{"location":"language/types/built_in_types/#explicit-subtypes","title":"Explicit subtypes","text":"<p>Explicit subtypes are fairly straightforward. They are useful when you are passing in parameters to a function, where you want a strict type on the list, or perhaps an empty list where no type assumptions can be made. </p> <pre><code>fun handleList(list) {\n    if (list is string[]) {\n        print(\"String list\")\n    } else if (list is int[]) {\n        print(\"Int list\")\n    } else {\n        print(\"Unknown list\")\n    }\n}\n\nhandleList(string[\"a\", \"b\", \"c\"])  // Prints \"String list\"\nhandleList(int[1, 2, 3])  // Prints \"Int list\"\nhandleList(int[])  // Prints \"Int list\"\nhandleList([])  // Prints \"Unknown list\"  - No explicit subtype\n</code></pre>"},{"location":"language/types/built_in_types/#subtype-transformations","title":"Subtype transformations","text":"<p>Sometimes when a list is created, it may have ambiguous types that should actually be all the same. An example of this is if a list of song IDs (strings) are present in a <code>song[]</code>. The Qilletni feature of subtype transformations allow the system to attempt to convert the string to the real type.</p> <pre><code>song[] songs = song[\"0PmoG29VeyZEEWuSJyfizZ\", \"https://open.spotify.com/track/58z4qdwM0zpWJEGfjSptR7?si=1d6a32c7f04b4c98\", \"6BVH6nyMBj601mSaUbbqKc\"]\nprint(songs)\n// ^ Prints: [song(\"Deception\" by \"Glae\"), song(\"Feel the Pressure\" by \"DRAIN\"), song(\"Where Light Divides the Holler\" by \"Knocked Loose\")]\n</code></pre> <p>This feature only works with expressions that would normally be able to be assigned to their type, such as an ID or URL string. This only works with lists of an explicit type, so the following would NOT work:</p> <pre><code>song[] songs = [\"0PmoG29VeyZEEWuSJyfizZ\", \"6BVH6nyMBj601mSaUbbqKc\"]  // Errors! This assigns a string[] to a song[]\n</code></pre> <p>The following table shows the supported type transformations.</p> From Type To Type Description of input <code>string</code> <code>song</code> ID or URL of the song <code>string</code> <code>album</code> ID or URL of album <code>string</code> <code>collection</code> ID or URL of collection <code>int</code> <code>double</code> Any int"},{"location":"language/types/built_in_types/#maps","title":"Maps","text":"<p>Maps are a normal Qilletni entity, acting as a wrapper of Java's HashMap. They may be created with <code>new Map()</code> or <code>Map.fromList()</code> which takes in a list of even size and pairs items together. They may store anything.</p> <pre><code>Map map = new Map()\nmap.put(\"a\", 1)\nmap.put(\"b\", 2)\nprint(map.get(\"a\"))  // Prints: \"1\"\n</code></pre> <p>The functions available for Map are available in the Map docs.</p>"},{"location":"language/types/built_in_types/#optional","title":"Optional","text":"<p>Because Qilletni doesn't support the concept of an empty/null value, Optionals are used to ensure the programmer is always aware of when a value isn't present. They typically should only be used for return values.</p> <p>The Optional entity defines the following static methods to create an Optional:</p> <pre><code>Optional a = Optional.fromEmpty()\nOptional b = Optional.fromValue(\"Hello\")\n</code></pre> <p>An Optional can have its empty status checked with <code>hasValue()</code> and have its value inspected with <code>getValue()</code>. The latter will exit the program and throw an error if no value is found in the optional.</p> <p>The functions available for Map are available in the Optional docs.</p> <pre><code>Optional a = Optional.fromEmpty()\n\nprintf(\"Value: %b\", [a.hasValue()])  // Prints \"false\"\n\nany aValue = a.getValue()  // Errors! No value is found\n</code></pre>"},{"location":"language/types/built_in_types/#any","title":"any","text":"<p>The <code>any</code> type is similar to <code>dynamic</code> in other languages. It may be any type, and it may be reassigned to any type. When using this, it is suggested to use the <code>is</code> type check.</p> <p>This type is specifically useful when dealing with lists that may contain multiple types, such as:</p> <pre><code>any[] multiTypes = any[\"a\", 1, false]\n</code></pre>"},{"location":"language/types/built_in_types/#music-types","title":"Music Types","text":"<p>Qilletni's whole purpose is dealing with music, so certain functions are baked into the language to assist with that.</p> <p>All music data is handled by the currently active Service Provider. A service provider assumes there is an ID present for each song, album, collection, and artist. The individual service provider has the ability to parse URLs to extract the relevant ID present. For examples, assume whenever you see an ID, a URL may also be passed in.</p> <p>If the internal package config property <code>eagerLoad</code> is <code>true</code>, the music type will be immediately queried, and will error out if invalid. If the property is not found or <code>false</code>, it will be queried whenever the first method that references a property of the type is invoked. See the following example where <code>eagerLoad</code> is <code>false</code>:</p> <pre><code>song mySong = \"Haunted\" by \"Burdened Hearts\"  // Song is not loaded yet, no API calls have been made\n\nprint(mySong.getAlbum())  // The song is queried. Prints 'album(\"The Best of Times\" by \"Burdened Hearts\")'\n</code></pre> <p>When using a title and an artist, native music types are defined by the following syntax:</p> <pre><code>&lt;type&gt; &lt;variable name&gt; = &lt;title&gt; &lt;type&gt; by &lt;artist&gt;\n</code></pre> <p>By default, the <code>&lt;type&gt;</code> before <code>by</code> defaults to <code>song</code>, so it may not be included. So for example, definitions may be</p> <pre><code>song s1 = \"Impulse\" by \"Harroway\"\nsong s2 = \"Heavy Rain\" song by \"Konami Kode\"\nalbum a1 = \"Nublar\" album by \"XO Armor\"\ncollection c1 = \"Polish RAVE\" collection by \"rubbaboy\"\n</code></pre>"},{"location":"language/types/built_in_types/#songs","title":"Songs","text":"<p>The <code>song</code> type in Qilletni represents a song that may be played on a streaming service. A service provider may also count something like a podcast as a song. It is uniquely identified by an ID, identified (sometimes ambiguously) by one or more artists and a title, and has an album. A <code>song</code> may be defined by the following:</p> <pre><code>song s1 = \"Fauna\" by \"Apothica\"\nsong s2 = \"2HdTQdGeProvKc35VdNfhD\"\nsong s3 = \"https://open.spotify.com/track/2HdTQdGeProvKc35VdNfhD?si=3060f8808cdd4d8c\"\n</code></pre> <p>All the above songs define the same song. For a song to be added to the queue, playlist, etc. the <code>play</code> keyword is used. By default, this adds it to the queue, however it may be redirected to perform other actions, dependent on the service provider.</p> <pre><code>play \"Dirty Floor\" by \"Sypha\"  // Adds the song to the queue\n</code></pre> <p>An example from the spotify library to add songs to a list is:</p> <pre><code>// Route all played songs to this list\nsong[] songList = []\nredirectPlayToList(songList)\n\nplay \"Child's Play\" by \"Hara Kiri\"\nplay \"Terror\" by \"Dread Engine\"\n\nprint(songList)  // Prints: '[song(\"Child's Play\" by \"Hara Kiri\"), song(\"Terror\" by \"Dread Engine\")]'\n</code></pre> <p>This may be useful if you want to batch add songs to a playlist, perform some kind of analysis on it, etc.</p> <p><code>play</code> redirects are covered more (// TODO)</p>"},{"location":"language/types/built_in_types/#albums","title":"Albums","text":"<p>The <code>album</code> type represents an album that songs may be on, with an ID, name, and one or more artists. An album may be defined by:</p> <pre><code>album a1 = \"Here &amp; Now\" album by \"Framework\"\nalbum a2 = \"7ulI5y1UiuepuQD61gcKHo\"\nalbum a3 = \"https://open.spotify.com/album/7ulI5y1UiuepuQD61gcKHo?si=1Ip8PdIdTQKCtlJiXFhyIg\"\n</code></pre> <p>The above album definitions all represent the same albums.</p> <p>Planned Feature</p> <p>Fetching songs from albums is a planned feature. It is already possible natively from within a service provider.</p>"},{"location":"language/types/built_in_types/#playlists","title":"Playlists","text":"<p>In Qilletni, a playlist is abstracted as a <code>collection</code>. A collection is what it sounds like, a collection of songs. A collection may be more than just a playlist though, it may be dynamically created from a list of songs, or may represent some other kind of song list sourced by a service provider (a list of top songs, for instance). A collection contains some basic information regarding it, such as the ID, the creator, song count, songs, and name. A collection may be defined as the following:</p> <pre><code>collection c1 = \"rage death kill\" collection by \"rubbaboy\"\ncollection c2 = \"2fupEjJ1lamW0dfAsXJag6\"\ncollection c3 = \"https://open.spotify.com/playlist/2fupEjJ1lamW0dfAsXJag6?si=45dd2429fd0a46ba\"\ncollection c4 = collection([\"Empath\" by \"Fayne\", \"Full Tilt\" by \"Johnny Booth\", \"7L7\" by \"Above This\"])  // (1)!\ncollection c5 = collection(listVar) // (2)!\n</code></pre> <ol> <li>Creates an in-memory collection with 3 songs in it</li> <li>Creates an in-memory collection of the songs in the given <code>song[]</code> list</li> </ol> <p>The first three collections all define the same playlist. <code>c4</code> and <code>c5</code> are defined by a cast-like syntax, taking in a song list within the <code>collection( )</code>. The created collection doesn't exist other than in the program's memory, but may act like any other collection.</p> <p>A collection may also have weights assigned to it, along with an order, in the syntax of:</p> <pre><code>collection c1 = \"Chill Bruh Moment\" collection by \"rubbaboy\" order[shuffle] weights[myWeights]\n</code></pre> <p>Where <code>myWeights</code> is a variable of type <code>weights</code>. <code>order</code> may either by \"shuffle\" or \"sequential\", defaulting to the former if unspecified. To see more information regarding weights, see Weights.</p> <p>Collections may be played in a similar way playlists are, just with an additional option.</p> <pre><code>play \"96 crayons\" by \"rubbaboy\" limit[10]\n</code></pre> <p>The above will play 10 shuffled songs from the given playlist. Instead of a number, the limit parameter may also be a time, such as <code>1h</code> to play 1 hour of songs (it will stop as soon as 1+ hour has been hit) or <code>15m</code> for 15 minutes of songs.</p> <p>Note this may also be given a variable, as the above is simply an expression.</p> <pre><code>play myPlaylist limit[30m]  // Plays 30 minutes of songs\n</code></pre>"},{"location":"language/types/built_in_types/#artists","title":"Artists","text":"<p>Artists aren't handled as natively as other music types are, as they are an entity. The entity consists of a name and a unique ID. Below are examples of getting an artist:</p> <pre><code>song mySong = \"Orchid Street\" by \"Arimea\"\n\nArtist artist = mySong.getArtist()\nprintf(\"Artist id: '%s' name: '%s'\", [artist.getId(), artist.getName()])  // Prints \"Artist id: '6qNHuzJVAGJ8h2D0qo6wAh' name: 'Arimea'\"\n</code></pre>"},{"location":"language/types/built_in_types/#weights","title":"Weights","text":"<p>Weights in Qilletni are a unique way of playlist orchestration. They manipulate the way Qilletni chooses which songs to play while playing from a collection. The following is an example of a simple weight definition.</p> <pre><code>weights demoWeights =\n    | 25% \"MANGO\" by \"This Is Falling\"\n    | 25% \"Reflections\" by \"I Sworn\"\n</code></pre> <p>The above weights, when applied to a collection, make \"MANGO\" play 25% of the time, for every song picked from the playlist. Likewise, \"Reflections\" is played 25% of the time, independently to anything else. For percent multipliers, the song doesn't necessarily have to be in the collection it's applied to. If all the percent multipliers add up to 100%, the songs in the collection will be ignored. Note the separator <code>|</code>. This disallows for the songs to repeat, allowing for a less repetitive mix. To fine tune this, see Weight Separators.</p> <p>Below is a visualization of a normal random shuffle of 20 songs through a playlist, and the same playlist with weights applied. The playlist consists of 10 songs, including \"MANGO\" and \"Reflections\". In the rest of this, the same playlist and visualization techniques will be used, just with different weights to highlight differences.</p>"},{"location":"language/types/built_in_types/#nested-weights","title":"Nested Weights","text":"<p>Weights can give you some more advanced control over how your songs are chosen from weights. Nested weights allow for the system to choose a song from a child weight every time the parent weight is chosen. Child weights (ones that are nested) must contain only percentages that add up to 100%, as something from it is always chosen. For example, the below code is equivalent to the previous example:</p> <pre><code>weights childWeights =\n    | 50% \"MANGO\" by \"This Is Falling\"\n    | 50% \"Reflections\" by \"I Sworn\"\n\nweights demoWeights =\n    | 50% childWeights\n</code></pre> <p>This is equivalent because originally, each song had a 25% chance of being chosen. <code>childWeights</code> has a 50% chance of being chosen, and each song in <code>childWeights</code> has an additional 50% chance. <code>0.50 * 0.50 = 0.25 = 25%</code></p>"},{"location":"language/types/built_in_types/#function-call-weights","title":"Function Call Weights","text":"<p>Along with nested weights, weights allow for function calls instead of chosen a song from a child weight. This acts the same as adding a child weight, but with a function (optionally with parameters) that is evaluated every time the weight is chosen. The function must always return a song. The following example is also equivalent to the last two.</p> <pre><code>fun mySongFunction() {\n    if (random(0, 10) &lt; 5) {  // 50% of the time\n        return \"MANGO\" by \"This Is Falling\"\n    } else {\n        return \"Reflections\" by \"I Sworn\"\n    }\n}\n\nweights demoWeights =\n    | 50% mySongFunction()\n</code></pre>"},{"location":"language/types/built_in_types/#collection-weights","title":"Collection Weights","text":"<p>Weights may also use a collection to choose what song to play when a weight is selected. The song is selected as it would normally be played from the collection. This includes its own weights, ordering, etc. For example, these are two code examples, one with a collection that's shuffled, and onme that is ordered, and a visualization of their outputs. The playlist <code>child playlist</code> contains the songs <code>\"I\"</code>, <code>\"II\"</code>, and <code>\"III\"</code>.</p> <pre><code>weights demoWeights =\n    | 50% \"child playlist\" collection by \"rubbaboy\"  // By default shuffled\n\nweights demoWeights =\n    | 50% \"child playlist\" collection by \"rubbaboy\" order[sequential]\n</code></pre> <p>As you can see, when the child playlist is sequential, each time a song is selected from the collection, it is the next song in the collection.</p>"},{"location":"language/types/built_in_types/#list-weights","title":"List Weights","text":"<p>Similar to collection weights, a weight may take in a list of songs as shorthand to defining a collection expression. This is functionally a shorthand of creating a collection that is shuffled. Each time a song is selected from the list, it is randomly chosen and played. Below is an example of a shorthand list weight, and then the equivalent with using a <code>collection</code>.</p> <pre><code>weights demoWeights =\n    | 50%  [\"I\" by \"BLACKSHAPE\", \"II\" by \"BLACKSHAPE\", \"III\" by \"BLACKSHAPE\"]\n\nweights demoWeights =\n    | 50%  collection([\"I\" by \"BLACKSHAPE\", \"II\" by \"BLACKSHAPE\", \"III\" by \"BLACKSHAPE\"]) order[shuffle]\n</code></pre>"},{"location":"language/types/built_in_types/#weight-separators","title":"Weight Separators","text":"<p>Weights also allow for more fine grain control. The separator before each line in the weights <code>|</code> may be replaced with one of the following. The below table shows the separator and what it does when the weight is selected. In the context of the table, an individual weight is the line in the <code>weights</code> expression. So it may be a song, function call, weight, or a collection.</p> Separator Character Song Repeats Weight Repeats Description <code>|</code> This song may not be chosen next, but the weight may be <code>|!</code> Both the song/line and the weight may be chosen next <code>|~</code> Neither the song nor the weight may be chosen next <p>The column Song Repeats is the song that is chosen from the collection, function, etc. If applied to a single song, the Weight Repeats column may be the same as the Song Repeats column.</p> <p>Below is another visualization of using the separators, using the following code:</p> <pre><code>weights childWeights =\n    | 50% \"MANGO\" by \"This Is Falling\"\n    | 50% \"Reflections\" by \"I Sworn\"\n\nweights demoWeights =\n    | 50% childWeights\n\nweights demoWeights =\n    |! 50% childWeights\n\nweights demoWeights =\n    |~ 50% childWeights\n</code></pre>"},{"location":"language/types/built_in_types/#multiplicative-weights","title":"Multiplicative Weights","text":"<p>A less obtrusive way of shuffling a playlist is using multiplicative weights. Instead of having a set probability for every time a song is played, they simply increase the chance a song is played. This takes the following format:</p> <pre><code>weights demoWeights =\n    | 5x \"Reflections\" by \"I Sworn\"\n</code></pre> <p>\"Reflections\" is played 5x as often as it normally would, assuming it is in the collection (if it's not, it will do nothing). In other words, imagine the collection was taken and \"Reflections\" was in there once. This will act as if it was in it 5 times. If it was originally in the collection twice, it will show up 10 times.</p> <p>Let's say the collection has 10 songs in it, one being \"Reflections\". The following is a shuffle of 20 songs from the playlist, before and after the 5x multiplicative weight.</p>"},{"location":"language/types/built_in_types/#java-references","title":"Java References","text":"<p>Java references are useful for interfacing with native methods that may require some special data to be associated with the field (or often times with the containing entity). A Java reference may be assigned with either the keyword <code>empty</code> to signify a null Java reference internally, or as a return value from a function (usually a native function).</p> <pre><code>java myRef = empty\njava funcRet = someNativeMethod()\n</code></pre> <p>To see more how a Java reference is used, see the Native Binding Reference.</p>"},{"location":"language/types/entities/","title":"Entities","text":"<p>An entity in Qilletni is a reusable template/blueprint that contains a set number of fields and methods in its own scope, that may be instantiated to encapsulate data. In Java, this would be considered a class.</p> <p>An entity is relatively basic, the following is an example of some of the features supported.</p> <pre><code>entity User {\n    int _id // (1)!\n    string username\n    boolean alive = true // (2)!\n\n    User(_id, username) // (3)!\n\n    /* (4)! */static fun createPerson(username) {\n        int id = random(0, 100)\n        return new User(id, username)\n    }\n\n    fun getId() {\n        return _id\n    }\n}\n\nUser user = User.createPerson(\"bob\")\nprint(user)  // Prints: \"User(alive = true, _id = 0, username = bob)\"\n</code></pre> <ol> <li>A private field, that can not be accessed outside the entity</li> <li>A predefined field, that can not be in the constructor</li> <li>A constructor is required with all the fields without values</li> <li><code>static</code> methods may be invoked without an instance of the entity, such as <code>User.createPerson</code></li> </ol> <p>Below is an in-depth overview of all supported features of an entity.</p>"},{"location":"language/types/entities/#fields","title":"Fields","text":"<p>An entity has a constant set of fields, meaning more fields may not be added during runtime. As with any variable in Qilletni, a field may not have no value, so fields must be either have a value given or be specified in the constructor.</p> <p>Accessing a field in an entity is done with the accessor notation, <code>.</code></p> <pre><code>User user = new User(1, \"Alice\")\n\nprint(user.username)\nuser.username = \"Jane\"\n</code></pre> <p>Fields that begin with an underscore may not be accessed from outside of the entity.</p> <pre><code>int i = user._id  // Invalid\n</code></pre> <p>It is standard to use public fields and not getters unless needed.</p>"},{"location":"language/types/entities/#constructors","title":"Constructors","text":"<p>A constructor is very simple, and only sets uninitialized fields in the entity. It does not support code execution upon initialization, for that it is recommended to use a static method initializer. The order of fields in a constructor don't matter, and may use private fields.</p>"},{"location":"language/types/entities/#functions","title":"Functions","text":"<p>Functions may be defined in an entity like a normal method. Similarly to fields, functions that begin with an underscore may not be accessed outside of the entity.</p>"},{"location":"language/types/entities/#static-functions","title":"Static Functions","text":"<p>Static functions do not need to be accessed with an instance of the entity, so they don't have access to any fields the entity has. They are used usually for initialization of an entity that may need special restrictions or code invoked during initialization.</p> <pre><code>entity Car {\n    int speed\n\n    Car(speed)\n\n    static fun create() {\n        return new Car(0)\n    }\n\n    fun getSpeed() {\n        return speed\n    }\n}\n\nCar.create()    // Returns new Car\nCar.getSpeed()  // Error, must be invoked on an instance of Car\n</code></pre>"},{"location":"language/types/entities/#string-visualization","title":"String Visualization","text":"<p>Similar to other languages, Qilletni supports a <code>toString()</code> function to visualize the string representation of an entity.</p> <p>If the function <code>toString()</code> is defined, it will be called when getting the string representation of an entity, such as printing it out. This may also be called directly.</p> <p>For example, if the following function was inserted in the entity <code>User</code> from the first section of this page:</p> <pre><code>fun toString() {\n    return \"User(id=%d, username='%s')\".format([_id, username])\n}\n</code></pre> <p>Then printing out a user would look like:</p> <pre><code>User(id=1, username='bob')\n</code></pre>"},{"location":"language/types/type_system/","title":"Type System","text":"<p>Documentation in progress</p> <p>Although the Qilletni type system is relatively simple, this page is currently under development. See the other pages in this section for information on types for now.</p>"},{"location":"misc/debug/","title":"Debugging","text":"<p>Debugging in Qilletni is supported, supporting back traces, inspections of scope, and more.</p> <p>To use debugging functions, it must be enabled through the <code>debug</code> property in the internal package config. This can be done via</p> <pre><code>qilletni persist internal debug=true\n</code></pre> <p>Once that is enabled, <code>std:breakpoint.ql</code> may be imported, and when <code>breakpoint()</code> is invoked, it will bring up a REPL debug console capable of running Qilletni code.</p> <p>In this console <code>std:debug/debug.ql</code> is automatically imported, which provides functions used for seeing the current state of the program.</p>"},{"location":"misc/debug/#debugging-example","title":"Debugging Example","text":"<p>This is a simple example showing how a breakpoint can be used, with some basic introspection.</p> <p>This program doesn't do much, but sets a breakpoint in a function.</p> <pre><code>import \"std:breakpoint.ql\"\n\ncollection castedCol1 = collection([\"Lost in Echoes\" by \"Caskets\", \"Cremation Party\" by \"Ithaca\"])\n\nprint(\"Directly casted collection:\")\nprint(castedCol1.toVerboseString())\n\nfun testFun(x, col) {\n    printf(\"original x = %d\", [x])\n\n    x++\n    breakpoint()\n\n    printf(\"modified x = %d\", [x])\n}\n\nint a = 10\nint b = 20\n\ntestFun(a, castedCol1)\n</code></pre> <p>Once this is ran, the following is what the debug console might look like, running <code>vars()</code> to see the variables in all scopes, and <code>backtrace()</code> to see the current stack trace of the program.</p> <pre><code>Directly casted collection:\ncollection(\"Lost in Echoes\" by \"Caskets\", \"Cremation Party\" by \"Ithaca\")\noriginal x = 10\nfilename.ql:12:0  &gt; breakpoint()\n&gt;&gt; vars()\n\nScope fun vars (id: 26) (current)\n   - No variables in scope -\n    Scope file local (id: 25)\n     - No variables in scope -\n      Scope global (id: 0)\n      a: 11\n      b: 20\n      castedCol1: collection(list-expression)\n\nScope file local (id: 16)\n   - No variables in scope -\n    Scope global (id: 0) (already printed)\n\nScope fun testFun (id: 20)\n  col: collection(list-expression)\n  x: 11\n    Scope file local (id: 16) (already printed)\n\nScope file local (id: 25)\n  Scope file local (id: 25) (already printed)\n&gt;&gt; backtrace()\nStack trace:\n        at [lib] breakpoint(..) debug_test.ql:12:4\n        at [lib] testFun(..) debug_test.ql:20:0\n&gt;&gt; continue\nmodified x = 11\n</code></pre> <p>The output is relatively low-level, showing how Qilletni sees the scope and variables internally. Variable names are highlighted in the console for better viewing in large programs.</p> <p>Info</p> <p>The REPL is relatively basic at the moment, so it's best to stick with the functions in <code>debug.ql</code></p>"},{"location":"misc/hosting_docs/","title":"Hosting Docs","text":"<p>Qilletni may generate docs for a package in a stateful way, allowing for cross-package references for extension methods. For instance, if you have package A with an entity, and package B has an extension method on that entity, when you generate docs, it will update the docs for package A to show the extension method, making it easier to see what functions are available for each type.</p> <p>Because of this, a stateful cache of the parsed packages is needed. When a package's docs are generated, the internal structure of each file is cached, so the system can easily add extension methods on cross-referenced types.</p> <p>Documentation in progress</p> <p>This page has been truncated and will be rewritten due to a recent overhaul in how docs are hosted. For now, see Qilletni/qilletni-package-docs to see how https://docs.qilletni.dev/ is hosted and generated via GitHub Actions.</p>"},{"location":"misc/ide_integration/","title":"IDE Integration","text":"<p>Qilletni offers an IntelliJ IDEA plugin, providing support for Qilletni and its features. It is currently not on the IntelliJ plugin marketplace due to it having some known issues, but it is functional for Qilletni development.</p> <p>Documentation in progress</p> <p>This page is a stub for now. For information on IDE integration, see the repo: Qilletni/QilletniPlugin.</p>"},{"location":"misc/package_configs/","title":"Package Configs","text":"<p>Qilletni offers the ability for libraries and the internal system to store persistent, user-editable key value strings. This is useful for authentication, program settings, etc.</p> <p>The <code>qilletni persist</code> command is used to manage this data from the command line. The format is:</p> <pre><code>qilletni persist &lt;libraryName&gt;  [-ar] [&lt;data&gt;...]\n</code></pre> <p>The package name may either be <code>internal</code>, for the Qilletni system itself, or an actual package name, such as <code>spotify</code> or <code>lastfm</code>. To view all properties of a library, use the <code>--all</code> or <code>-a</code> flag, such as:</p> <pre><code>$ qilletni persist internal --all\n| Property       | Value |\n| -------------- | ----- |\n| eagerMusicLoad | true  |\n</code></pre> <p>To remove a value, use the <code>--remove</code> or <code>-r</code> flag, such as:</p> <pre><code>$ qilletni persist internal -r eagerMusicLoad\nRemoving: eagerMusicLoad\n</code></pre> <p>To set a value, simply do <code>key=value</code>. This may be done multiple times in the same command.</p> <pre><code>$ qilletni persist internal eagerMusicLoad=true foo=bar\nParameter 'eagerMusicLoad' set to 'true' in package 'internal'.\nParameter 'foo' set to 'bar' in package 'internal'.\n\n$ qilletni persist internal --all\n| Property       | Value |\n| -------------- | ----- |\n| foo            | bar   |\n| eagerMusicLoad | true  |\n</code></pre> <p>Viewing specific values is done by just putting in the key name, without an <code>=</code> after. There may be multiple, and also mixed with setting values. If mixed with setting values, the values being viewed will be printed first, and then set.</p> <pre><code>$ qilletni persist internal eagerMusicLoad\n| Property       | Value |\n| -------------- | ----- |\n| eagerMusicLoad | true  |\n</code></pre>"},{"location":"misc/package_configs/#using-in-native-libraries","title":"Using In Native Libraries","text":"<p>In a native library, from Java, package configs can be used via a native injected class, injecting the PackageConfig class, as shown below.</p> <pre><code>public class MyLibraryFunctions {\n    private final PackageConfig packageConfig;\n\n    public MyLibraryFunctions(PackageConfig packageConfig) {\n        this.packageConfig = packageConfig;\n    }\n}\n</code></pre> <p>To use this, the package config may be accessed via get(String) and set(String, String). More methods are outlined in the javadocs. To save the config, you must use the saveConfig() method.</p>"},{"location":"misc/package_configs/#using-in-qilletni-code","title":"Using In Qilletni Code","text":"<p>Currently, package configs are only supported at the native level. To get a interact with data, a native method can be made to access or write to it.</p>"},{"location":"native_binding/background_tasks/","title":"Background Tasks","text":"<p>The Qilletni language itself is strictly single threaded, and does not have plans to become multithreaded. Native methods in Java, however, may call Qilletni code from another thread with the use of background tasks through the BackgroundTaskExecutor. This is useful when a native method is polling an API, waiting for an IPC call or webhook, and then needs to tell Qilletni about it. This also lets Qilletni be useful in a server context.</p> <p>A background task is broken down into two parts: a callback and a condition. A callback is a Runnable or a Consumer that is invoked when a condition is triggered. A condition is identified by an ID, and may be triggered in any Java thread. The callback is always ran on the Qilletni thread, which may do normal Qilletni operations, such as invoking a function or modifying a variable.</p> <p>The following is an example of creating a condition and getting its ID.</p> <pre><code>// BackgroundTaskExecutor backgroundTaskExecutor; FunctionType callback;  TypeConverter typeConverter;  FunctionInvoker functionInvoker;\n\nfinal int conditionId = backgroundTaskExecutor.runWhenCondition((String songName) -&gt; {  // (1)!\n    List&lt;QilletniType&gt; args = typeConverter.convertToQilletniTypes(List.of(songName));  // (2)!\n    functionInvoker.invokeFunction(callback, args);\n});\n</code></pre> <ol> <li>Everything ran in this method is on the Qilletni thread</li> <li>Create the arguments from a Java list to QilletniType list</li> </ol> <p>The above code tells the BackgroundTaskExecutor to run the given Consumer when returned <code>conditionId</code> is triggered. The way to trigger this condition is:</p> <pre><code>backgroundTaskExecutor.triggerCondition(conditionId, \"My Song\");\n</code></pre> <p>In this instance, the Consumer accepted a string. This could be any object, which allows cross-thread parameters. Note that you must do any Qilletni type conversion in the callback.</p> <p>In Qilletni, a program may complete while a background task is running. To circumvent this, the <code>processBackground()</code> function may be invoked, which stops the program indefinitely, letting background tasks complete. </p>"},{"location":"native_binding/introduction/","title":"Native Bindings","text":"<p>Native bindings in Qilletni allow for the use of Java code in a normal program to add functionality either computationally expensive or otherwise impossible in the language itself. Currently, bindings use native methods (which are the things actually bound to Java methods) and the <code>java</code> type which may hold a reference to a Java object, accessible through a native method.</p> <p>See the following resources for more information regarding native bindings:</p> <ul> <li>Native Methods to see how native methods are set up and work</li> <li>Native Bind Factories to see how custom objects can be injected into native method's classes</li> <li>Usage Examples for more advanced examples of how native binding works, including property accessing and invoking Qilletni methods from a Java method</li> </ul> <p>These pages will assume you have a project set up with native bindings enabled. See the Project Structure section on this for setting it up.</p>"},{"location":"native_binding/native_bind_factories/","title":"Native Bind Factories","text":"<p>Native bind factories are used to add instances of a class to the system to allow it to be injected into the constructor that contains a native method.</p> <p>The following is an example of using injected instances:</p> <pre><code>public class MyLibraryFunctions {\n\n    private final EntityInitializer entityInitializer;\n    private final SongTypeFactory songTypeFactory;\n\n    public MyLibraryFunctions(EntityInitializer entityInitializer, SongTypeFactory songTypeFactory) {\n        this.entityInitializer = entityInitializer;\n        this.songTypeFactory = songTypeFactory;\n    }\n}\n</code></pre> <p>The order of the parameters don't matter, nor do they necessarily need to be set to a class member variable, but it is recommended to. It is not recommended to execute code in the constructor, that should be reserved for methods annotated with @BeforeAnyInvocation as outlined here.</p>"},{"location":"native_binding/native_bind_factories/#predefined-injectable-classes","title":"Predefined Injectable Classes","text":"<p>Below is a list of all classes that are injectable by default, with a brief description of their purpose.</p> Class Description MusicPopulator Often ran in a @BeforeAnyInvocation method, this force-populates a given music type with its service provider data, as lazy loading of types may allow there to be no lookup of the type yet EntityDefinitionManager Handles lookups and defining entities EntityInitializer Initializes entities by name or definition with constructor args, supporting auto-conversion of types ListInitializer Creates ListTypes from values, either Qilletni or Java. SongTypeFactory Creates a SongType from a Track CollectionTypeFactory Creates a CollectionType from a Playlist AlbumTypeFactory Creates an AlbumType from an Album FunctionInvoker Invokes a Qilletni function, allowing for callbacks TypeConverter Converts Qilletni types to Java types and back DynamicProvider Manages the current service provider, with getters for internal PackageConfig A scoped instance (see section below) of the current library's config BackgroundTaskExecutor Allow for async Qilletni callbacks, outlined in the Background Tasks page"},{"location":"native_binding/native_bind_factories/#adding-custom-injectable-classes","title":"Adding Custom Injectable Classes","text":"<p>Sometimes, you have your own factories or other classes that you want injected into classes with native methods. To do this, first you must implement the NativeFunctionBindingFactory class. Then, add it to the qilletni_info.yml file, such as:</p> qilletni_info.yml<pre><code># ...\nnative_bind_factory: dev.qilletni.lib.spotify.SpotifyNativeFunctionBindingFactory\n</code></pre> <p>The implementation of this interface may look something like this:</p> SpotifyNativeFunctionBindingFactory<pre><code>public class SpotifyNativeFunctionBindingFactory implements NativeFunctionBindingFactory {\n\n    @Override\n    public void applyNativeFunctionBindings(NativeFunctionClassInjector nativeFunctionClassInjector) {\n        nativeFunctionClassInjector.addInjectableInstance(new PlaylistCreator(SpotifyApiSingleton.getSpotifyAuthorizer()));\n    }\n}\n</code></pre> <p>This will now allow the spotify library's class, <code>PlaylistCreator</code> to be used in classes containing native methods, such as:</p> PlaylistToolsFunctions.java<pre><code>public class PlaylistToolsFunctions {\n    private final PlaylistCreator playlistCreator;\n\n    public PlaylistToolsFunctions(PlaylistCreator playlistCreator) {\n        this.playlistCreator = playlistCreator;\n    }\n}\n</code></pre>"},{"location":"native_binding/native_bind_factories/#scoped-injectable-classes","title":"Scoped Injectable Classes","text":"<p>Not all injectable instances may need to be injected into all classes. Qilletni offers the ability to scope the injectable classes via class name, allowing more restricted access to them. This also lets you have multiple native method classes taking in different instances of the same class or interface. Below is an example of setting a scoped injectable class, and two classes trying to use it.</p> CatNativeFunctionsBindingFactory.java<pre><code>public class CatNativeFunctionsBindingFactory implements NativeFunctionBindingFactory {\n\n    @Override\n    public void applyNativeFunctionBindings(NativeFunctionClassInjector nativeFunctionClassInjector) {\n        nativeFunctionClassInjector.addScopedInjectableInstance(new CatSitter(), List.of(CatFunctions.class));\n    }\n}\n</code></pre> CatFunctions.java<pre><code>public class CatFunctions {\n    private final CatSitter catSitter;\n\n    public CatFunctions(CatSitter catSitter) {  // Works\n        this.catSitter = catSitter;\n    }\n}\n</code></pre> LitterBoxFunctions.java<pre><code>public class LitterBoxFunctions {\n    private final CatSitter catSitter;\n\n    public LitterBoxFunctions(CatSitter catSitter) {  // Fails; Can't find injectable CatFunctions instance\n        this.catSitter = catSitter;\n    }\n}\n</code></pre>"},{"location":"native_binding/native_functions/","title":"Native Methods","text":"<p>Native methods in Qilletni are functions that are bound to a Java method. They are defined like a normal method signature, but with no body. For instance,</p> <pre><code>native fun getHostname()\n</code></pre> <p>This page will go over how to use these functions, how to implement them, etc.</p>"},{"location":"native_binding/native_functions/#setting-up-a-native-project","title":"Setting Up a Native Project","text":"<p>If you haven't created a project with native bindings, see the the Project Structure page for setting it up. In the <code>native_classes</code> section of your <code>qilletni_info.yml</code> file, ensure a Java class' canonical name is present. This should already be present in the project's template.</p> <p>The naming standard of files with native methods in them is <code>XyzFunctions</code>, such as <code>CatFunctions</code>. For example,</p> qilletni_info.yml<pre><code># ...\nnative_classes:\n  - dev.qilletni.lib.cats.CatFunctions\n</code></pre>"},{"location":"native_binding/native_functions/#creating-a-basic-function","title":"Creating a Basic Function","text":"<p>The following is a basic example of a function, in the class mentioned above.</p> cats.ql<pre><code>native fun getCatNames()\n\nstring[] names = getCatNames()\nprint(names)  // Prints \"[Olive, Johnny, Oyster]\"\n</code></pre> CatFunctions.java<pre><code>public class CatFunctions {\n    public List&lt;String&gt; getCatNames() {\n        return List.of(\"Olive\", \"Johnny\", \"Oyster\");\n    }\n}\n</code></pre> <p>Qilletni offers the ability to both automatically convert to/from certain types when methods are invoked, and also some manual conversions. The following Java method is what it would look like without automatic conversions.</p> CatFunctions.java<pre><code>public class CatFunctions {\n    private final ListAdapter listAdapter;\n\n    public CatFunctions(ListAdapter listAdapter/*(1)!*/) {\n        this.listAdapter = listAdapter;\n    }\n\n    public ListType getCatNames() {\n        var list = List.of(\"Olive\", \"Johnny\", \"Oyster\");\n        return listAdapter.createListFromJava(list);\n    }\n}\n</code></pre> <ol> <li>This type is automatically injected into the class when the method is invoked. See Native Bind Factories for other classes that may be injected.</li> </ol> <p>The following is a basic example of a function that takes in a parameter. For demonstration, they are mixed in both auto converted types and an unconverted type.</p> <pre><code>native fun findAvgAge(cat1, cat2)\n</code></pre> <pre><code>public int findAvgAge(int cat1, IntType cat2) {\n    int cat2Age = cat2.getValue();\n    return (cat1 + cat2Age) / 2;\n}\n</code></pre> <p>It is recommended to use automatic type conversion, but is not necessary. For a list of all automatic type conversions, see Automatic Type Conversion.</p>"},{"location":"native_binding/native_functions/#qilletni-type-structure","title":"Qilletni Type Structure","text":"<p>Native types in Qilletni are all subtypes of QilletniType. A method may both return or take in any QilletniType.</p>"},{"location":"native_binding/native_functions/#automatic-type-conversion","title":"Automatic Type Conversion","text":"<p>To assist with dealing with built-in Qilletni types, Qilletni will automatically convert certain types to their Java counterparts. They convert both in method parameters and in the return type. The following is a table with the built-in type converters. The reason why there are duplicates is when a parameter is passed in from Qilletni, it converts it from a QilletniType to a Java type. When a Java type is returned, it converts it to a QilletniType.</p> From To Notes BooleanType boolean boolean BooleanType IntType long long IntType IntType int int IntType DoubleType double double DoubleType StringType String String StringType ListType List Currently, items inside a list are not transformed to Java types List ListType A list must contain only the same type Map (Entity) HashMap Converts the std lib's Map to a HashMap Object JavaType If a native method returns an Object (any non-converted class), it will be given to Qilletni as a JavaType"},{"location":"native_binding/native_functions/#skipping-automatic-type-conversion","title":"Skipping Automatic Type Conversion","text":"<p>If a type is returned and you don't want it to automatically convert, such as returning a JavaType of HashMap without converting it to the Map entity, the @SkipReturnTypeAdapter annotation may be used on the method. The following is an example that is used in the Map entity itself, to initialize a Java type of HashMap.</p> MapFunctions.java<pre><code>@SkipReturnTypeAdapter\npublic static Object _emptyJavaMap() {\n    return new HashMap&lt;&gt;();\n}\n</code></pre>"},{"location":"native_binding/native_functions/#dealing-with-entities","title":"Dealing With Entities","text":"<p>Entities are a little more complicated to handle in native methods, as they are inherently more complex than the predefined types. Luckily, Qilletni has the full ability to manipulate them and make your own.</p> <p>When an entity instance is passed into a native method, it is passed in as an EntityType. To access the fields or functions in the entity, getEntityScope() can be used, as shown below.</p> cats.ql<pre><code>entity Cat {\n    string name\n    int age\n\n    Cat(name, age)\n}\n\nnative fun sayHello(cat)\n\nCat cat = new Cat(\"Beer\", 2)\nsayHello(cat)  // Prints \"Hello Beer, you are 2 years old!\"\n</code></pre> CatFunctions.java<pre><code>public class CatFunctions {\n    public void sayHello(EntityType catEntity) {\n        StringType stringType = catEntity.getEntityScope().&lt;StringType&gt;lookup(\"name\").getValue();\n        String name = stringType.getValue();\n\n        IntType intType = catEntity.getEntityScope().&lt;IntType&gt;lookup(\"age\").getValue();\n        long age = intType.getValue();\n\n        System.out.println(\"Hello %s, you are %d years old!\".formatted(name, age));\n    }\n}\n</code></pre> <p>The first lookup() call returns the Symbol, which is an internal representation of a variable that may hold any Qilletni type. From there, the value from each is gotten which is the actual type instance. Note that IntTypes are internally represented as <code>long</code>s.</p> <p>If a variable is changed, the Symbol does not need to be re-set, but it can be. An example of a variable being updated is:</p> cats.ql<pre><code>native fun catBirthday(cat)\n\nCat cat = new Cat(\"Beer\", 2)\ncatBirthday(cat)\n\nprint(cat)  // Prints \"Cat(name = Beer, age = 3)\"\n</code></pre> CatFunctions.java<pre><code>public void catBirthday(EntityType catEntity) {\n    IntType age = catEntity.getEntityScope().&lt;IntType&gt;lookup(\"age\").getValue();\n    age.setValue(age.getValue() + 1);\n}\n</code></pre>"},{"location":"native_binding/native_functions/#entityrecord-conversion","title":"Entity/Record Conversion","text":"<p>Entities may also be automatically converted to and from Java records, using the TypeConverter class. The instance of this class is acquired through automatic injection, see Native Bind Factories for more information, and the other classes available to use. Below is an example of taking in an entity and automatically converting it to a record.</p> cats.ql<pre><code>entity Cat {\n    string name\n    int age\n\n    Cat(name, age)\n}\n\nnative fun sayHello(cat)\n\nCat cat = new Cat(\"Beer\", 2)\nsayHello(cat)  // Prints \"Hello Beer, you are 2 years old!\"\n</code></pre> CatFunctions.java<pre><code>public class CatFunctions {\n    private final TypeConverter typeConverter;\n\n    public CatFunctions(TypeConverter typeConverter) {\n        this.typeConverter = typeConverter;\n    }\n\n    private record Cat(String name, int age) {}\n\n    public void sayHello(EntityType catEntity) {\n        Cat cat = typeConverter.convertFromEntityToRecord(catEntity, Cat.class);\n        System.out.println(\"Hello %s, you are %d years old!\".formatted(cat.name(), cat.age()));\n    }\n}\n</code></pre> <p>The above code uses the convertFromEntityToRecord method to take an EntityType, and map its properties to a Java record that has fields of the same name.</p> <p>Similarly, the convertFromRecordToEntity method does the opposite, taking a Record and mapping it to an EntityType, matching its values up with the constructor of the entity, as shown below. This assumes the Cat entity is still defined.</p> cats.ql<pre><code>native fun createNewCat(name, age)\n\nCat cat = createNewCat(\"Martini\", 3)\nprint(cat)  // Prints \"Cat(name = Martini, age = 3)\"\n</code></pre> CatFunctions.java<pre><code>public EntityType createNewCat(String name, int age) {\n    Cat cat = new Cat(name, age);\n    return typeConverter.convertFromRecordToEntity(\"Cat\", cat);\n}\n</code></pre>"},{"location":"native_binding/native_functions/#native-entity-functions","title":"Native Entity Functions","text":"<p>Qilletni also supports native entity member functions. This is defined in Qilletni the same as a normal native method, just in the entity.</p> cats.ql<pre><code>entity Cat {\n    string name\n    int age\n\n    Cat(name, age)\n\n    native fun pet()\n}\n</code></pre> <p>Implementing this function in Java uses the @NativeOn annotation on the method. This takes in the entity name this is on (<code>on</code> in a similar context to an extension method's syntax). Any native method on an Entity must accept an EntityType as its first parameter (note this is not reflected in the Qilletni signature). This is the instance of the entity that the method is being invoked on.</p> CatFunctions.java<pre><code>@NativeOn(\"Cat\")\npublic void pet(EntityType catEntity) {\n    StringType name = catEntity.getEntityScope().&lt;StringType&gt;lookup(\"name\").getValue();\n    System.out.println(\"Petting %s!\".formatted(name.getValue()));\n}\n</code></pre> <p>Often times a whole Java class is dedicated for native methods on an entity. The @NativeOn annotation may also be applied to a class definition, making all methods that line up with signatures native methods, as shown below. As with the case of normal native methods, the first parameter is the entity instance.</p> CatFunctions.java<pre><code>@NativeOn(\"Cat\")\npublic class CatFunctions {\n    public void pet(EntityType catEntity) {\n        StringType name = catEntity.getEntityScope().&lt;StringType&gt;lookup(\"name\").getValue();\n        System.out.println(\"Petting %s!\".formatted(name.getValue()));\n    }\n}\n</code></pre>"},{"location":"native_binding/native_functions/#native-static-entity-functions","title":"Native Static Entity Functions","text":"<p>Static methods on entities may also have native definitions. These are the same as a normal native method on an entity, but instead of accepting an EntityType, it accepts a StaticEntityType. This provides the method with context regarding the entity definition, and the static scope of the entity.</p>"},{"location":"native_binding/native_functions/#injectable-types","title":"Injectable Types","text":"<p>Qilletni providers a set of classes that may be put in the constructor, and are populated when a native method is invoked. It also has the ability to inject your own classes to be used both by other libraries or scoped to just your own. See the Native Bind Factories page for more information on this.</p>"},{"location":"native_binding/native_functions/#preload-methods","title":"Preload Methods","text":"<p>Sometimes, especially in the case of when many methods are being performed on the same entity, a common action must happen before any of the methods get invoked. Executing code other than member variable setting is not recommended, so for this, the @BeforeAnyInvocation annotation may be used on a single method in the class, which will be invoked before the body of any native method is ran. This method takes one parameter, which is the EntityType the method is being invoked on. This may set up instance variables (as there is one instance of the class for every call) or do anything else necessary. The example below is from the standard library std-lib, ensuring the song is populated with service provider data before an invocation is made on it.</p> SongFunctions.java<pre><code>@NativeOn(\"song\")\npublic class SongFunctions {\n    private final MusicPopulator musicPopulator;\n\n    public SongFunctions(MusicPopulator musicPopulator) {\n        this.musicPopulator = musicPopulator;\n    }\n\n    @BeforeAnyInvocation\n    public void setupSong(SongType songType) {\n        musicPopulator.populateSong(songType);\n    }\n\n    public String getTitle(SongType songType) { // (1)!\n        return songType.getTrack().getName();\n    }\n}\n</code></pre> <ol> <li>If the <code>@BeforeAnyInvocation</code> method wasn't ran and the song hadn't been loaded yet, getTrack() would be null.</li> </ol>"},{"location":"official_packages/json/","title":"Json","text":"<p>The JSON package is a simple JSON serializer and deserializer for Qilletni types. All types are supported, including lists, arbitrary entities, nested objects, and Maps.</p> <p>The primary functions in the package are <code>createJsonConverter()</code>, <code>toJson(obj)</code> and <code>fromJson(str)</code>. Examples are found in the package's examples directory, but some are outlined below.</p>"},{"location":"official_packages/json/#basic-serializationdeserialization","title":"Basic Serialization/Deserialization","text":"<p>This shows basic deserialization, modification, and serialization ofa simple JSON object.</p> <pre><code>import \"json:json.ql\"\n\nstring jsonStr = \"{\\\"a\\\": \\\"Hello\\\", \\\"c\\\": 5}\"\n\nJsonConverter json = JsonConverter.createJsonConverter(true)\n\nMap map = json.fromJson(jsonStr)\nprint(\"a = \" + map.get(\"a\"))\nprint(\"c = \" + map.get(\"c\"))\n\nint c = map.get(\"c\")\n\nprint(\"cint = \" + c)\n\nmap.put(\"b\", \"World\")\nmap.put(\"c\", map.get(\"c\") + 5)\n\nprint(json.toJson(map))\n</code></pre> <p>Output:</p> <pre><code>a = Hello\nc = 5\ncint = 5\n{\"a\":\"Hello\",\"b\":\"World\",\"c\":10}\n</code></pre>"},{"location":"official_packages/json/#serialization-with-list","title":"Serialization With List","text":"<p>A demonstration of native Qilletni-provided map/list construction. The below example would be used when serializing a known structure of data, rather than using a string.</p> <pre><code>import \"json:json.ql\"\n\nMap map = Map.fromList(any[\"one\", \"two\", \"three\", any[1, 2, 3, 4]])\n\nJsonConverter json = JsonConverter.createJsonConverter(true)\n\nprint(json.toJson(map))\n</code></pre> <p>Output:</p> <pre><code>{\"one\":\"two\",\"three\":[1,2,3,4]}\n</code></pre>"},{"location":"official_packages/json/#nestedmixed-type-introspection","title":"Nested/Mixed Type Introspection","text":"<p>This example deserializes a JSON string into a Map, and checks the type of each value in the inner list. This shows proper type assumptions.</p> <pre><code>import \"json:json.ql\"\n\nstring jsonStr = \"{\\\"a\\\": [1, 2, 3.3, 4, [\\\"a\\\", \\\"b\\\", \\\"c\\\"], 5]}\"\n\nprint(\"jsonStr = \" + jsonStr)\n\nJsonConverter json = JsonConverter.createJsonConverter(true)\n\nMap map = json.fromJson(jsonStr)\nprint(\"a = \" + map.get(\"a\"))\n\nfor (var : map.get(\"a\")) {\n    if (var is int) {\n        print(\"var is int: \" + var)    \n    } else if (var is double) {\n        print(\"var is double: \" + var)\n    } else if (var is []) {\n        print(\"var is list: \" + var)\n    }\n}\n\nany[] someList = [1, 2, 3, [\"a\", \"b\", \"c\"], 5] // (1)!\nMap jsonMap = new Map()\njsonMap.put(\"a\", someList)\n\nprint(json.toJson(jsonMap))\n</code></pre> <ol> <li>A similar JSON object to serialize, with <code>3</code> instead of <code>3.3</code>.</li> </ol> <p>Output:</p> <pre><code>jsonStr = {\"a\": [1, 2, 3.3, 4, [\"a\", \"b\", \"c\"], 5]}\na = [1, 2, 3.3, 4, [a, b, c], 5]\nvar is int: 1\nvar is int: 2\nvar is double: 3.3\nvar is int: 4\nvar is list: [a, b, c]\nvar is int: 5\n{\"a\":[1,2,3,[\"a\",\"b\",\"c\"],5]}\n</code></pre>"},{"location":"official_packages/official_packages/","title":"Official Packages","text":"<p>This section contains descriptions, information and examples for official Qilletni packages, in the <code>@qilletni</code> scope. All Qilletni packages have hosted documentation at https://docs.qilletni.dev/.</p> <p>For information on using packages, see Packages.</p> <p>More package pages coming soon</p> <p>The packages on https://docs.qilletni.dev/ are all complete, but most lack dedicated pages here. Check each library's <code>examples/</code> directory for examples on usage.</p>"},{"location":"official_packages/service_providers/lastfm/","title":"Last.fm","text":"<p>The Last.fm package is a limited service provider that does not implement the native feature set. Due to the nature of Last.fm, some concepts don't cleanly carry over to Qilletni, such as user playlists.</p> <p>The following features are implemented as part of the native feature set:</p> <ul> <li>Song lookup</li> <li>Artist lookup</li> <li>Music type conversion</li> </ul> <p>All other features that are Last.fm specific are provided by functions in the library, documented in <code>lastfm.ql</code>.</p> <p>All root-level methods in the library return a <code>LastFmResult</code>, which is an entity that wraps the result of a Last.fm API call. To ensure that this library returns standard Qilletni music types that can be easily used and converted (such as <code>song[]</code> or <code>Artist[]</code>), the library places these direct types in the <code>data</code> field of the result.</p> <p>For responses that include metadata with the music type list, additional information is stored in the <code>wrappedData</code> field. For example, the <code>getTopTracks(user)</code> function returns <code>song[]</code> as its <code>data</code> field, but <code>wrappedData</code> is a <code>TopTrack[]</code>, which contains fields for <code>track</code> (the <code>song</code> also in the <code>data</code> list), <code>playCount</code> and <code>rank</code>.</p> <p>The following is an example of using the library, and using the result to another service provider:</p> <pre><code>import \"lastfm:lastfm.ql\"\nimport \"spotify:playlist_tools.ql\"\n\nprovider \"lastfm\"\n\nPage page = new Page()\n                ..page = 1\n                ..count = 100\n\nLastFmResult result = getTopTracks(\"RubbaBoy\", \"3month\", page)\n\nif (result.isError()) {\n    printf(\"Error: %s\", [result.errorMessage])\n    exit(1)\n}\n\nfor (track : result.wrappedData.getValue()) { // (1)!\n    printf(\"%s\\t plays  %s\", [track.playCount, track.track])\n}\n\nprovider \"spotify\"\n\ncollection newPlaylist = createPlaylist(\"Top Song Playlist\")\naddToPlaylist(newPlaylist, result.data) // (2)!\n\nprint(\"Created a playlist with %s songs\".format([result.data.size()]))\n</code></pre> <ol> <li>Prints out an ordered list of the top played tracks</li> <li><code>result.data</code> is a <code>song[]</code>, so it's automatically converted to use with a new Spotify playlist</li> </ol>"},{"location":"official_packages/service_providers/spotify/","title":"Spotify","text":"<p>The Spotify package is a service provider implementing the full native feature set with additional capabilities including playlist management, playing, and Spotify's recommendation API. In this page, the user refers to the Spotify account that is logged into Qilletni.</p>"},{"location":"official_packages/service_providers/spotify/#features","title":"Features","text":""},{"location":"official_packages/service_providers/spotify/#playing-songs","title":"Playing Songs","text":"<p>The Spotify <code>play</code> keyword is implemented to add the played song to the user's Spotify queue. The queue functionality has two modes: blocking and non-blocking, controlled via the blocking_queue.ql file. </p>"},{"location":"official_packages/service_providers/spotify/#non-blocking-mode","title":"Non-blocking Mode","text":"<p>Non-blocking mode simply puts the song at the end of the queue, and immediately continues with the program. Depending on the program, this could add a lot of songs to the queue at once, but may be beneficial in cases where an immediately exiting program is desired.</p> <p>This uses significantly less Spotify API calls.</p>"},{"location":"official_packages/service_providers/spotify/#blocking-mode","title":"Blocking Mode","text":"<p>Blocking mode waits until the song is almost finished, and then adds it to the queue. This is useful for when the queue should have minimal songs in it, or the program is using time-based features, such as checking the time of day while playing music.</p> <p>As the name implies, blocking mode blocks the program until the next song is almost finished playing (when 75% of the song's duration has passed). Once it is ready, the program continues, and if applicable, the next song is added to the queue.</p> <p>This uses significantly more Spotify API calls, as polling is required to check when the song is almost finished playing.</p> <p>To help control the number of API calls made, the Spotify package provides a fast poll option, which uses a much faster polling mechanism. When enabled, the Spotify package will poll every 5 seconds, rather than once towards the end of the currently playing song. This adds significantly more API calls, but is the better choice if the user tends to skip, pause, or seek Spotify songs frequently.</p>"},{"location":"official_packages/service_providers/spotify/#hooks","title":"Hooks","text":"<p>Hooks provide a way to inspect what songs are currently being played by the user, provided by <code>onSongPlay(fn)</code>. This method accepts a callback function, and polls the Spotify user account every 5 seconds (this is configurable). This callback is passed a <code>song</code> parameter, and is the song being played.</p> <p>The following is an example of using a hook:</p> <pre><code>import \"spotify:hooks.ql\"\n\nprovider \"spotify\"\n\nfun songPlayCallback(sng) {\n    printf(\"Playing:\\t%s - %s\", [sng.getTitle(), sng.getArtist().getName()])\n}\n\nonSongPlay(songPlayCallback)\n\n// Halt program forever, running background tasks\nprocessBackground()\n</code></pre>"},{"location":"official_packages/service_providers/spotify/#playlist-tools","title":"Playlist Tools","text":"<p>The Spotify package provides a few tools for working with playlists, provided by <code>playlist_tools.ql</code>. This includes creating playlists and adding songs to them. Below are some simple examples of adding songs to a new playlist:</p> <pre><code>import \"spotify:playlist_tools.ql\"\n\ncollection created = createPlaylist(\"New Playlist\")\n\nsong[] songs = [\"Remember Me\" by \"Currents\"]\n\naddToPlaylist(created, songs)\n</code></pre> <p>A more common usecase is using <code>redirectPlayToList(songList)</code> to make all <code>play</code> calls to instead place the song in a list, then adding those songs to a playlist. </p> <pre><code>import \"spotify:playlist_tools.ql\"\n\nsong[] songList = []\nredirectPlayToList(songList)\n\nplay \"Spiral\" by \"Feyn Entity\"\nplay \"Anxiety\" by \"Breakwaters\"\n\ncollection myNewPlaylist = createPlaylist(\"Qilletni generated\")\n\naddToPlaylist(myNewPlaylist, songList) // (1)!\n</code></pre> <ol> <li>Both songs are added to the new playlist</li> </ol> <p>This also works while playing a collection. The following example plays 5 random songs from a collection, then adds them to a playlist.</p> <pre><code>import \"spotify:playlist_tools.ql\"\n\nsong[] songList = []\nredirectPlayToList(songList)\n\nplay \"My Playlist\" collection by \"Bob\" order[shuffle] limit[5]\n\ncollection myNewPlaylist = createPlaylist(\"Qilletni generated\")\n\naddToPlaylist(myNewPlaylist, songList)\n</code></pre>"},{"location":"official_packages/service_providers/spotify/#recommendation-api","title":"Recommendation API","text":"<p>The full Spotify recommendation API is available for use, provided by the <code>Recommender</code> entity.</p> <p>This entity provides a significant amount of options, so only a few will be covered here. This entity is created with these fields set, and <code>recommend()</code> is invoked, returning a <code>song[]</code> of recommended songs.</p> <p>Below is an example of using the Recommendation API using some common options:</p> <pre><code>import \"spotify:recommendations.ql\"\n\nRecommender recommender = new Recommender()\n        ..seedTracks = [\"Cremation Party\" by \"Ithaca\", \n                        \"I Am A Fault\" by \"156/Silence\",\n                        \"Distance\" by \"Sleep Waker\",\n                        \"Mr. Parker\" by \"Void of Echoes\"]\n        ..targetEnergy = 0.8\n        ..targetPopularity = 50\n        ..targetSpeechiness = 0.8\n        ..targetValence = 0.3\n\nsong[] recs = recommender.recommend(10) // (1)!\n\ncollection collectionOfRecs = collection(recs) // (2)!\n\nplay collectionOfRecs // (3)!\n</code></pre> <ol> <li>Recommend 10 songs</li> <li>Cast the <code>song[]</code> to an in-memory collection</li> <li>Add the songs to your queue</li> </ol>"},{"location":"official_packages/service_providers/tidal/","title":"Tidal","text":"<p>The Tidal package is a service provider implementing the full native feature set with additional capabilities such as playlist management planned soon. Due to API limitations, the <code>play</code> is unable to add to the user's queue.</p>"},{"location":"official_packages/service_providers/tidal/#features","title":"Features","text":""},{"location":"official_packages/service_providers/tidal/#smart-fuzzy-searching","title":"Smart Fuzzy Searching","text":"<p>Tidal supports native fuzzy searching, which is provided by a search strategy. Typically in a service provider, a song is looked up by its title and artist, and the best match is returned from the API (which may have some fuzzyness) if it wasn't in the song database.</p> <p>With Tidal, it was observed that the search API was less accurate in some instances than expected, so a custom search strategy was implemented. This will search a song's title and artist, and run an algorithm to identify which of the results is the best match (exact matches are preferred). Once found, the searched title and artist are stored with the song as an alias, so future queries for this can go directly to the database.</p> <p>Search strategies are provided by Qilletni, with implementations dependent on the service provider. This logic will likely come to other service providers soon.</p> <p>The following is an example of using the search strategy. See the tooltips for descriptions of both lookups.</p> <pre><code>import \"tidal:tidal.ql\"\nimport \"std:provider.ql\"\n\nprovider \"tidal\"\n\nsetFetchResolveStrategy(\"fuzzy\")\n\nsong jealous = \"Jealous\" by \"Chromeo\" // (1)!\n\nsong cachedJealous = \"Jealous\" by \"Chromeo\" // (2)!\n</code></pre> <ol> <li>Makes an API call, and resolves to <code>\"Jealous (I Ain't With It)\" by \"Chromeo\"</code>, which is a fuzzy match to    <code>\"Jealous\" by \"Chromeo\"</code> which is now in the database, and does not need fuzzy searching for future lookups</li> <li>Makes a database lookup, no API call needed</li> </ol> <p>To set the search strategy to the default one, use <code>setFetchResolveStrategy(\"default\")</code>. From here, database lookups are only used for exact matches.</p>"},{"location":"packages/documenting/","title":"Documenting Packages","text":"<p>Qilletni features a custom documentation generator tailored to the languages' needs. Official Qilletni packages are documented and hosted at https://docs.qilletni.dev/.</p>"},{"location":"packages/documenting/#the-documentation-generator","title":"The Documentation Generator","text":"<p>The documentation generator is accessed from the <code>qilletni doc</code> command. The generator creates a full static website from either a project's source, or from an existing Qilletni Library (<code>.qll</code>) file. This static website may host multiple packages' documentation, with an index page updated automatically.</p> <p>Info</p> <p>The generator currently only supports single package scopes across a single deployment directory.</p>"},{"location":"packages/documenting/#using-the-generator","title":"Using The Generator","text":"<p>Generating documentation is straightforward. Run <code>qilletni doc</code> in the project's root directory, using the <code>-o</code> param to specify the output directory, with the target <code>qilletni_src</code> directory or <code>.qll</code> file following.</p> <p>For instance, if you are in a project's root, to generate documentation into the <code>docs</code> directory, run:</p> <pre><code>qilletni doc -o docs/ qilletni_src/\n</code></pre> <p>To specify a cache directory (see the below section on stateful generation), use the <code>-c</code> param:</p> <pre><code>qilletni doc -o docs/ -c cache/ qilletni_src/\n</code></pre> <p>The default cache directory is <code>.qilletni/cache</code>.</p> <p>To regenerate all packages' documentation in the cache, use the <code>-r</code> parameter:</p> <pre><code>qilletni doc -o docs/ -r\n</code></pre>"},{"location":"packages/documenting/#stateful-generation","title":"Stateful Generation","text":"<p>The Qilletni documentation generator is unique in the fact it allows for cross-referencing libraries in the case of extension functions. For instance, take a package A and B. B defined an entity, which its own generated page, showing functions. If A defines a function that extends that entity, then the function will be documented both in A, and the type defined in B. This leaves out any guesswork of what's available on an entity when using multiple libraries at once.</p> <p>This is implemented by storing information about each docstring in a cache file, named <code>&lt;package-name&gt;.cache</code> in <code>~/.qilletni/cache</code> (or wherever else specified). When generating documentation for a package, if it has an extension function on another package's entity, it will look for that package in the cache and update it to include the function. Then, the documentation is regenerated for that package as well.</p>"},{"location":"packages/documenting/#generated-documentation-features","title":"Generated Documentation Features","text":"<p>Aside from cross-package referencing, the documentation generator supports some more advanced features:</p>"},{"location":"packages/documenting/#searching","title":"Searching","text":"<p>When documentation is generated, an index is generated which allows for fast searching through a packages' documentation. This search is scoped on a per-package basis.</p> <p></p>"},{"location":"packages/documenting/#file-tree-navigation","title":"File Tree Navigation","text":"<p>For each package documented, the full tree of files is displayed, allowing for easy navigation and understanding of a whole package's structure. Files can be individually inspected, showing what is defined in it. Likewise, each entity, function, and field are linked to the file of its definition.</p> <p></p>"},{"location":"packages/documenting/#writing-documentation","title":"Writing Documentation","text":"<p>Docstrings are formatted in a Java-like way. Markdown is supported, with several custom <code>@directives</code> included. A docstring supports the following directives:</p> <pre><code>/**\n * Some text regarding the [@type boolean] type.\n *\n * @param    x A parameter named `x`\n * @returns  Returns a value\n * @type string\n * @on int\n * @errors Throws an error if `x` is negative\n */\n</code></pre> <p>Below is a description, with examples, of each directive. Some directives may be used inline with text, surrounded in <code>[]</code>. In these cases, that includes any body of text, such as the main docstring, param description, etc.</p>"},{"location":"packages/documenting/#type","title":"@type","text":"<p>A directive that may be used directly on a variable declaration, inline in any description, or applied to <code>@param</code>, <code>@returns</code> and <code>@on</code>. <code>@java</code> may be added before the type name to indicate the type is a fully qualified Java class name.</p> <p>The following is an example of using <code>@type</code> on a variable declaration: <pre><code>/**\n * A map of data\n * @type @java java.util.HashMap\n */\njava _someData\n</code></pre></p> <p>And some examples of using <code>@type</code> inline: <pre><code>/**\n * An reference to a [@type @java java.util.concurrent.locks.Lock] may be stored in a [@type java] Qilletni type.\n */\n</code></pre></p> <p>When referencing a non-native Qilletni type, the library name must be specified before the type name:</p> <pre><code>/**\n * This is how the [@type spotify.Recommendations] type is documented.\n */\n</code></pre>"},{"location":"packages/documenting/#param","title":"@param","text":"<p>Describes a parameter of a function or constructor, with an optional type and description. This may be used inline in text to reference a parameter in what's being documented. Below is an example of referencing a parameter, and documenting it:</p> <pre><code>/**\n * Some documentation talking about the [@param x] parameter.\n *\n * @param x A parameter named x\n */\n</code></pre> <p>A type is specified in this directive by writing a type in <code>[]</code> after the directive, before the parameter name, such as</p> <pre><code>/**\n * @param[@type string]                  x  A parameter named `x` of type `int`\n * @param[@type @java java.util.HashMap] y  A param accepting a Java type\n */\n</code></pre>"},{"location":"packages/documenting/#returns","title":"@returns","text":"<p>Specifies the return type of a function. Similar to <code>@param</code>, a type may be spefied.</p> <pre><code>/**\n * @returns[@type string] Returns a string\n */\n\n/**\n * @returns[@type @java java.util.Map] The returned map\n */\n</code></pre>"},{"location":"packages/documenting/#on","title":"@on","text":"<p>Allows an extension method to describe its target type. This also accepts a type. There is no need to specify a <code>@type</code> directive unless documenting a Java type.</p> <pre><code>/**\n * Prints out the given string\n *\n * @on The string to print out\n */\nfun printOut(str) on string {}\n</code></pre>"},{"location":"packages/documenting/#errors","title":"@errors","text":"<p>Describes when the documented function may throw an error, halting the program.</p> <pre><code>/**\n * @errors When a negative number is given\n */\n</code></pre>"},{"location":"packages/package_development/","title":"Package Development","text":""},{"location":"packages/package_development/#running-examples","title":"Running Examples","text":"<p>When working with packages, it is often useful to run code (such as <code>examples/</code>) using the package without building the <code>.qll</code> and installing it. This is possible through the <code>-l</code> and <code>-j</code> flags of <code>qilletni run</code>.</p> <p>Given the following tree:</p> <pre><code>package_name/\n\u251c\u2500\u2500 examples\n\u2502   \u2514\u2500\u2500 example1.ql\n\u2514\u2500\u2500 qilletni-src/\n    \u251c\u2500\u2500 package_name.ql\n    \u2514\u2500\u2500 qilletni_info.yml\n</code></pre> <p>To run the file <code>examples/example1.ql</code> with the package installed, run it with the <code>-l</code> flag. This specifies the directory of the root of the project, containing <code>qilletni-src/</code>. If no path is specified, the current directory will be used. For example:</p> <pre><code>~/package_name$ qilletni run -l examples/example1.ql\n</code></pre>"},{"location":"packages/package_development/#running-with-a-native-jar","title":"Running With A Native Jar","text":"<p>The run command may optionally build the native jar before running, using the <code>-j</code> flag. If the above example contained native code, it could be ran with:</p> <pre><code>~/package_name$ qilletni run -j -l examples/example1.ql\n</code></pre> <p>This will auto-detect the Gradle project and build the native jar.</p>"},{"location":"packages/package_development/#packages-in-gradle-submodules","title":"Packages in Gradle Submodules","text":"<p>Documentation in progress</p> <p>Qilletni has the ability to build packages in Gradle submodules. Documentation is coming soon, but in the meantime see how <code>qilletni/spotify</code> does this with its <code>.qilletni_build.properties</code> file.</p>"},{"location":"packages/package_management/","title":"Package Management","text":"<p>Package management in Qilletni is handled via the Qilletni Package Manager (QPM). QPM is a serverless package manager using Cloudflare Workers, using GitHub for authentication.</p> <p>QPM is used via the <code>qpm</code> command, installed in the Docker container and the normal system install.</p>"},{"location":"packages/package_management/#package-structure","title":"Package Structure","text":"<p>Packages consist of a scope, name, and version. The scope is either the name or organization the publisher has access to, granted by the authorization through GitHub. To set a scope, set the project's name to <code>&lt;scope&gt;/&lt;project name&gt;</code>. For an example, see the Full Publishing Example.</p> <p>A package version is in the format of <code>x.y.z</code>, with an optional <code>-SNAPSHOT</code> trailing the version. A non-snapshot release does not change once published (unless deleted). Snapshots may be re-published, with the <code>.qll</code> file replacing the old one every time. </p>"},{"location":"packages/package_management/#lock-files","title":"Lock Files","text":"<p>A lock file, <code>qilletni.lock</code>, is created in the project when a project is installed. This keeps track of all dependencies and subdependencies. When a project is installed, snapshot versions are always re-pulled from the server.</p>"},{"location":"packages/package_management/#usage","title":"Usage","text":"<p>To install packages in a fresh project, first enter the project's root (or the <code>qilletni_src</code>) directory. Then, run</p> <pre><code>qpm install\n</code></pre> <p>This will scan dependencies in the <code>qilletni_info.yml</code>, create a lock file, and download dependencies in <code>~/.qilletni/packages</code></p> <p>To publish a <code>.qll</code>, you must first be logged in via <code>qpm login</code>, and follow the prompts, such as:</p> <pre><code>$ qpm login\nInitiating GitHub authentication...\n\nPlease visit: https://github.com/login/device\nAnd enter code: 46A3-BF96\n\nWaiting for authentication...\n\u2713 Authenticated as: RubbaBoy\n</code></pre> <p>From here, you may now manage and upload your own packages. To publish a <code>.qll</code> file, use <code>qpm publish</code>:</p> <pre><code>qpm publish somelib-1.0.0.qll\n</code></pre>"},{"location":"packages/package_management/#full-publishing-example","title":"Full Publishing Example","text":"<p>The following is an example of creating, building and publishing a package. This creates a package named <code>publish-demo</code> with the scope of <code>RubbaBoy</code>.</p> <pre><code>$ qilletni init --type library --name RubbaBoy/publish-demo\nLock file not found, resolving dependencies...\nResolving dependencies for RubbaBoy/publish-demo...\n\u2713 Lock file created with 1 packages\nInstalling 1 packages...\n\n\u2713 qilletni/std@1.0.0 (already installed)\n\n\u2713 Installation complete!\nInstalled 1 package(s)\n$ cd publish-demo/\n$ qilletni build\nBuilt library to build/ql-build/publish-demo-1.0.0.qll\n$ qpm publish\nReading package: .\nPackage: RubbaBoy/publish-demo v1.0.0\nUploading package...\n\u2713 Package published successfully!\nName: @rubbaboy/publish-demo\nVersion: 1.0.0\nSize: 643 B\nIntegrity: sha256-tUSJ1H4ixx9sVht+3WQHCMqv57tJrt4X+ubyM92WqS0=\nadam@adam-pc:/e/QilletniLibraries/publish-demo$ \n</code></pre>"},{"location":"packages/package_management/#local-publishing","title":"Local Publishing","text":"<p>Packages can also be published locally, without a server. Currently, dependencies will only be resolved to a local dependency if the package name matches exactly.</p> <p>To publish a local package, use <code>qpm publish-local</code> in the same way as <code>qpm publish</code>.</p> <p>Info</p> <p>Local publishing is a new, and not thoroughly tested feature. If you encounter any issues, please make an issue here.</p>"},{"location":"packages/package_management/#publishing-with-github-actions","title":"Publishing With GitHub Actions","text":"<p>Publishing packages through CI/CD is also possible with the Qilletni Docker image. See the example below for a working workflow file that publishes to QPM on every release tagged <code>vX.Y.Z</code>.</p> publish_qpm.yml<pre><code>on:\n  push:\n    tags:\n      - 'v*.*.*'\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    container:\n      image: ghcr.io/qilletni/qilletni:snapshot\n\n    steps:\n      - uses: actions/checkout@v6\n\n      - name: Build Package\n        run: qilletni build\n\n      - name: QPM Publish\n        run: qpm publish\n        env:\n          QPM_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n</code></pre> <p>Note that the <code>qilletni build</code> is shorthand for <code>qilletni build .</code>, which builds the package that is in the current directory (the repository's root), and <code>qpm publish</code> finds the latest <code>.qll</code> file in the current project's build directory.</p>"},{"location":"quickstart/getting_started/","title":"Getting Started with Qilletni","text":"<p>Welcome to Qilletni, a Domain-Specific Language (DSL) designed for advanced playlist management, music curation, and seamless integration with Spotify and Java libraries.</p>"},{"location":"quickstart/getting_started/#introduction","title":"Introduction","text":"<p>Qilletni simplifies the creation and manipulation of playlists and music data, allowing you to automate tasks, integrate with external libraries, and leverage a rich standard library. If you\u2019d like a broader overview of Qilletni, see the Home page for more details.</p>"},{"location":"quickstart/getting_started/#installation","title":"Installation","text":""},{"location":"quickstart/getting_started/#start-database","title":"Start Database","text":"<p>Qilletni leverages a database for caching music data for efficient lookups and conversions. The easiest way to start a caching database is via docker, using a command such as:</p> <pre><code>docker run -d \\\n  --name qilletni-db \\\n  -p 5435:5432 \\\n  -e POSTGRES_USER=qilletni \\\n  -e POSTGRES_PASSWORD=pass \\\n  -e POSTGRES_DB=qilletni \\\n  -v ~/.qilletni/cache:/var/lib/postgresql/data \\\n  postgres\n</code></pre>"},{"location":"quickstart/getting_started/#install-qilletni","title":"Install Qilletni","text":"<p>There are two ways to use Qilletni. You may install it on your system, or use the Docker image. A normal system install is recommended (everything is put under <code>~/.qilletni</code>), but a Docker install is great for trying things out.</p>"},{"location":"quickstart/getting_started/#install-on-system","title":"Install on System","text":"<p>For a system install, first install you have at least Java 22 installed. To install Qilletni, run the following in a bash shell:</p> <pre><code>curl -L https://install.qilletni.dev/ | bash\n</code></pre> <p>This will install the commands <code>qilletni</code> and <code>qpm</code>, which are the primary toolchain, and the Qilletni Package Manager (QPM) respectively.</p> <p>Then, open a new shell or run <code>source ~/.bashrc</code></p> <p>From there, you can run <code>qilletni --help</code> or <code>qpm --help</code> for a list of commands.</p>"},{"location":"quickstart/getting_started/#use-with-docker","title":"Use with Docker","text":"<p>To use with Docker, run the following:</p> <pre><code>docker run --rm \\\n  --network host \\\n  -v \"/$(pwd)\":/workspace \\\n  -v qilletni-packages:/root/.qilletni/packages \\\n  ghcr.io/qilletni/qilletni:latest \\\n  qilletni --help\n</code></pre> <p>Which is equivalent to running <code>qilletni --help</code>. QPM is also accessible through this image.</p> <p>To run a file, it's recommended to <code>cd</code> into the parent directory of the file and run it from there. For example, to run <code>/e/qilletni/demo.ql</code> you would do, from the <code>/e/qilletni</code> directory,</p> <pre><code>docker run --rm \\\n  --network host \\\n  -v \"/$(pwd)\":/workspace \\\n  -v qilletni-packages:/root/.qilletni/packages \\\n  ghcr.io/qilletni/qilletni:latest \\\n  run demo.ql\n</code></pre>"},{"location":"quickstart/getting_started/#hello-world-your-first-program","title":"Hello World (Your First Program)","text":"<p>Let\u2019s create a simple \"Hello, World!\" program:</p> <ol> <li>Initialize a project Create a project directory, and then run the command</li> </ol> <pre><code>qilletni init --name qilletni_demo\n</code></pre> <p>It will ask you for a project name, and the author's name. In this case, we'll give it the name <code>qilletni_demo</code>. It will also ask for an optional native binding class name, which may be left blank for now.</p> <p>This will create a file tree of the following structure:</p> <pre><code>qilletni_demo/\n\u2514\u2500\u2500 qilletni-src/\n    \u251c\u2500\u2500 qilletni_demo.ql\n    \u251c\u2500\u2500 qilletni.lock\n    \u2514\u2500\u2500 qilletni_info.yml\n</code></pre> <p>The file created, <code>qilletni_demo.ql</code>, is the start of your source code. Right now, it only contains:</p> qilletni_demo.ql<pre><code>print(\"Hello, World!\")\n</code></pre> <p>A more in-depth explanation of the project structure, and other project types, can be found in the Project Structure guide.</p> <ol> <li>Run the program via command line:</li> </ol> <pre><code>qilletni run qilletni-src/qilletni_demo.ql\n</code></pre> <p>If everything is set up correctly, you should see:</p> <pre><code>Hello, World!\n</code></pre>"},{"location":"quickstart/getting_started/#next-steps","title":"Next Steps","text":"<p>Now that you have a Qilletni program running, it's time to link a music service. Check out the Spotify or Last.fm pages for more info. If you've done that, feel tree to check out the Language Introduction or some of the official packages.</p> <p>For making and using packages in Qilletni, navigate to Package Management.</p>"},{"location":"quickstart/lastfm_integration/","title":"Last.fm Integration","text":"<p>Last.fm integration is provided via the lastfm package, which is a Service Provider. Because it is a standalone package, it must be connected to Last.fm.</p>"},{"location":"quickstart/lastfm_integration/#api-setup","title":"API Setup","text":"<p>Because using Qilletni is essentially using an API and not an end application, you must create Last.fm API keys for your account.</p> <p>To create an API, sign into https://www.last.fm/api/account/create and fill out the information, and click Submit. The Callback URL is not required.</p> <p>From there, copy the API Key and Shared Secret, and run the following <code>qilletni</code> command in your console:</p> <pre><code>qilletni persist lastfm apiKey=api-key apiSecret=api-secret\n</code></pre> <p>Where <code>api-key</code> is your API Key, such as <code>f8ea7243239ec13d1ab6b858532c5b32</code>, and <code>api-secret</code> is your Shared Secret, such as <code>7f713e749d63adeab805ed78c9585f11</code>.</p>"},{"location":"quickstart/lastfm_integration/#database-setup","title":"Database Setup","text":"<p>The Last.fm package also needs database access for caching music data. If using the default Docker Postgres settings from Getting Started, the following settings are populated by default and do not need manual setting:</p> <pre><code>| Property     | Value                                             |\n| ------------ | ------------------------------------------------- |\n| dbUsername   | qilletni                                          |\n| dbUrl        | jdbc:postgresql://localhost:5435/qilletni_lastfm  |\n| dbPassword   | pass                                              |\n</code></pre> <p>To set these manually, the following may be ran:</p> <pre><code>qilletni persist lastfm dbUsername=.. dbUrl=.. dbPassword=..\n</code></pre>"},{"location":"quickstart/lastfm_integration/#using-the-package","title":"Using The Package","text":"<p>The following is a quick example of a Qilletni program. Follow the Getting Started guide to create a project, and add the following dependency in your <code>qilletni_info.yml</code> file:</p> qilletni_info.yml<pre><code>dependencies:\n  - lastfm:^1.0.0\n</code></pre> <p>And make a basic program, which checks the most recent 50 songs played on your account:</p> qilletni_demo.ql<pre><code>import \"lastfm:lastfm.ql\"\n\nLastFmResult result = getRecentTracks(\"RubbaBoy\")\n\nif (result.isError()) {\n    printf(\"Error: %s\", [result.errorMessage])\n    exit(1)\n}\n\nprintf(\"Recent Tracks:\\n\\t%s\", [result.data])\n</code></pre> <p>Which should output something similar to:</p> <pre><code>Recent Tracks:\n        [song(\"Euclid\" by \"Sleep Token\"), song(\"Take Me Back to Eden\" by \"Sleep Token\"), ...]\n</code></pre> <p>For more usage of the Last.fm package, see the Last.fm Package Page.</p>"},{"location":"quickstart/spotify_integration/","title":"Spotify Integration","text":"<p>Spotify integration is provided via the spotify package, which is a Service Provider. Because it is a standalone package, it must be connected to Spotify.</p>"},{"location":"quickstart/spotify_integration/#api-setup","title":"API Setup","text":"<p>Because using Qilletni is essentially using an API and not an end application, you must create Spotify API keys for your account.</p> <p>To create an API, sign into https://developer.spotify.com/dashboard and click <code>Create app</code> and fill in the <code>App name</code> and <code>App description</code>. Set the <code>Redirect URIs</code> field to <code>http://localhost:8088/spotify</code> and create the app.</p> <p>Copy the Client ID from the Basic Information tab, and run the following <code>qilletni</code> command in your console:</p> <pre><code>qilletni persist spotify redirectUri=http://localhost:8088/spotify clientId=client-id\n</code></pre> <p>Where <code>client-id</code> is your Client ID, such as <code>c92e7a91a4d1402bca2e26a9e25e2be6</code>.</p>"},{"location":"quickstart/spotify_integration/#database-setup","title":"Database Setup","text":"<p>The Spotify package also needs database access for caching music data. If using the default Docker Postgres settings from Getting Started, the following settings are populated by default and do not need manual setting:</p> <pre><code>| Property     | Value                                              |\n| ------------ | -------------------------------------------------- |\n| dbUsername   | qilletni                                           |\n| dbUrl        | jdbc:postgresql://localhost:5435/qilletni_spotify  |\n| dbPassword   | pass                                               |\n</code></pre> <p>To set these manually, the following may be ran:</p> <pre><code>qilletni persist spotify dbUsername=.. dbUrl=.. dbPassword=..\n</code></pre>"},{"location":"quickstart/spotify_integration/#using-the-package","title":"Using The Package","text":"<p>The following is a quick example of a Qilletni program. Follow the Getting Started guide to create a project, and add the following dependency in your <code>qilletni_info.yml</code> file:</p> qilletni_info.yml<pre><code>dependencies:\n  - spotify:^1.0.0\n</code></pre> <p>And make a basic program, which adds a song to your Spotify account's queue:</p> qilletni_demo.ql<pre><code>play \"Fireflies\" by \"Owl City\"\n</code></pre> <p>For more usage of the Spotify package, see the Spotify Package Page.</p>"},{"location":"quickstart/tidal_integration/","title":"Tidal Integration","text":"<p>Tidal integration is provided via the tidal package, which is a Service Provider. Because it is a standalone package, it must be connected to Tidal.</p>"},{"location":"quickstart/tidal_integration/#api-setup","title":"API Setup","text":"<p>Because using Qilletni is essentially using an API and not an end application, you must create Tidal API keys for your account.</p> <p>To create an API, sign into https://developer.tidal.com/dashboard/ and click <code>Create New App</code> and fill in the <code>App name</code> . Set the <code>Redirect URIs</code> field to <code>http://localhost:9099/tidal</code> and create the app.</p> <p>Copy the Client ID and the Client Secret, and run the following <code>qilletni</code> command in your console:</p> <pre><code>qilletni persist tidal redirectUri=http://localhost:9099/tidal clientId=.. clientSecret=..\n</code></pre> <p>Filling in your client ID and secret.</p>"},{"location":"quickstart/tidal_integration/#database-setup","title":"Database Setup","text":"<p>The Tidal package also needs database access for caching music data. If using the default Docker Postgres settings from Getting Started, the following settings are populated by default and do not need manual setting:</p> <pre><code>| Property     | Value                                              |\n| ------------ | -------------------------------------------------- |\n| dbUsername   | qilletni                                           |\n| dbUrl        | jdbc:postgresql://localhost:5435/qilletni_tidal    |\n| dbPassword   | pass                                               |\n</code></pre> <p>To set these manually, the following may be ran:</p> <pre><code>qilletni persist tidal dbUsername=.. dbUrl=.. dbPassword=..\n</code></pre>"},{"location":"quickstart/tidal_integration/#using-the-package","title":"Using The Package","text":"<p>The following is a quick example of a Qilletni program. Follow the Getting Started guide to create a project, and add the following dependency in your <code>qilletni_info.yml</code> file:</p> qilletni_info.yml<pre><code>dependencies:\n  - tidal:^1.0.0\n</code></pre> <p>And make a basic program, which gets the Tidal ID of a song:</p> qilletni_demo.ql<pre><code>song sng = \"Fireflies\" by \"Owl City\"\nprint(sng.getId())\n</code></pre> <p>For more usage of the Tidal package, see the Tidal Package Page.</p>"}]}